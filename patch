diff --git a/.editorconfig b/.editorconfig
index beffa30..c3f6353 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -2,7 +2,7 @@ root = true

 [*]
 indent_style = space
-indent_size = 2
+indent_size = 4
 charset = utf-8
 trim_trailing_whitespace = true
 insert_final_newline = true
diff --git a/.gitignore b/.gitignore
index f2afc22..66bc0f0 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,5 +4,7 @@ node_modules/
 tmp/
 typings/*
 !typings/custom/
+src/state.ts
+src/**/**.scss.d.ts
 .DS_Store
 *.log
diff --git a/.vscode/launch.json b/.vscode/launch.json
deleted file mode 100644
index 2fef16d..0000000
--- a/.vscode/launch.json
+++ /dev/null
@@ -1,21 +0,0 @@
-{
-  "version": "0.2.0",
-  "configurations": [
-    {
-      "name": "Launch Chrome with sourcemaps",
-      "type": "chrome",
-      "request": "launch",
-      "url": "http://localhost:3000",
-      "sourceMaps": true,
-      "webRoot": "${workspaceRoot}"
-    },
-    {
-      "name": "Attach to Chrome with sourcemaps",
-      "type": "chrome",
-      "request": "attach",
-      "port": 9222,
-      "sourceMaps": true,
-      "webRoot": "${workspaceRoot}"
-    }
-  ]
-}
diff --git a/.vscode/settings.json b/.vscode/settings.json
deleted file mode 100644
index ba48394..0000000
--- a/.vscode/settings.json
+++ /dev/null
@@ -1,9 +0,0 @@
-// Place your settings in this file to overwrite default and user settings.
-{
-  "files.exclude": {
-    "**/.git": true,
-    "**/.svn": true,
-    "**/.DS_Store": true,
-    "**/node_modules": true
-  }
-}
diff --git a/README.md b/README.md
deleted file mode 100644
index 60bbb9e..0000000
--- a/README.md
+++ /dev/null
@@ -1,5 +0,0 @@
-# dictionary-react-redux-typescript
-
-[![Build Status](https://travis-ci.org/goblindegook/dictionary-react-redux-typescript.svg?branch=master)](https://travis-ci.org/goblindegook/dictionary-react-redux-typescript)
-
-A simple React + Redux application written in TypeScript.
diff --git a/gulpfile.js b/gulpfile.js
new file mode 100644
index 0000000..b58b645
--- /dev/null
+++ b/gulpfile.js
@@ -0,0 +1,94 @@
+var gulp = require('gulp');
+var gutil = require('gulp-util');
+var tap = require('gulp-tap');
+var yaml = require('gulp-yaml');
+var rename = require('gulp-rename');
+var flat = require('flat');
+var _ = require('lodash');
+var fs = require('fs');
+
+require('typescript-require');
+
+var Json2Ts = require('./tools/json2ts').Json2Ts;
+var DtsCreator = require('typed-css-modules');
+
+var dtsCreator = new DtsCreator();
+var json2ts = new Json2Ts();
+
+function makeRefs(initialState) {
+    var state = JSON.parse(initialState);
+    flatten = flat.flatten(state);
+
+    /**
+     * Create new state reference
+     */
+    state = flat.unflatten(_.mapValues(flatten, function(value, key) {
+        return "<% injector.get(Ref).link('" + key + "') %>";
+    }));
+
+    /**
+     * Remove quotes
+     */
+    return JSON.stringify(state, null, 4).replace(/"<% (.*) %>"/g, "$1");
+}
+
+gulp.task('gen-state', function () {
+    gulp.src('./src/state.yml')
+        .pipe(yaml())
+        .pipe(tap(function(file) {
+            var content = file.contents.toString();
+            file.contents = new Buffer([
+                "import {memoize} from 'lodash'",
+                "import {Ref, IRef} from './core/Ref';",
+                "import injector from './core/Injector';",
+                json2ts.convert(content, "State", "I$"),
+                json2ts.convert(content, "State", "I$Ref", "IRef<$>"),
+                "export const initialState: IState = " + JSON.stringify(JSON.parse(content), null, 4) + ";",
+                "export const getStateRefs: () => IStateRef = memoize(() => { return " + makeRefs(content) + "});"
+                ].join('\n\n')
+            );
+        }))
+        .pipe(rename('state.ts'))
+        .pipe(gulp.dest('./src'));
+});
+
+function compileStyleDts(filepath) {
+    return dtsCreator.create(filepath).then(function(contents) {
+        gutil.log(
+            "compile", contents.rInputPath,
+            "[", "" + contents.rawTokenList, "]");
+        if (contents.messageList.length) {
+            gutil.log(contents.messageList.join('\n  '));
+        }
+        fs.writeFile(contents.rInputPath + '.d.ts', contents.resultList.join('\n'));
+    })
+}
+
+gulp.task('gen-styles-dts', function() {
+    gulp.src('./src/**/*.scss', {read: false})
+        .pipe(tap(function(file) {
+            compileStyleDts(file.path);
+        }));
+});
+
+gulp.task('watch-styles-dts', function() {
+    gulp.watch('./src/**/*.scss', function(event) {
+        if (_.includes(['deleted', 'renamed'], event.type)) {
+            fs.unlink(event.path + '.d.ts');
+        } else {
+            compileStyleDts(event.path);
+        }
+    });
+});
+
+gulp.task('watch-state', function () {
+    gulp.watch(['./src/state.yml'], ['generate-interfaces']);
+});
+
+gulp.task('dev', [
+    'gen-state',
+    'gen-styles-dts',
+    'watch-state',
+    'watch-styles-dts'
+]);
+
diff --git a/index.js b/index.js
index d19354d..6fb84eb 100644
--- a/index.js
+++ b/index.js
@@ -1,4 +1,4 @@
-'use strict'
-require('css-modules-require-hook/preset')
-require('ts-node/register')
-require('./src/server')
+require('css-modules-require-hook/preset');
+require('ts-node/register');
+require('./src/providers');
+require('./src/server');
diff --git a/package.json b/package.json
index 7f27be5..5acae1f 100644
--- a/package.json
+++ b/package.json
@@ -1,23 +1,17 @@
 {
-  "name": "dictionary-react-redux-typescript",
+  "name": "virtu",
   "version": "1.0.0",
-  "description": "A simple React and Redux application written in TypeScript.",
-  "repository": "git@github.com:goblindegook/dictionary-react-redux-typescript.git",
+  "description": "Small redux app",
   "main": "index.js",
   "scripts": {
-    "install": "typings install",
-    "start": "NODE_ENV=production node index.js",
+    "postinstall": "typings install",
+    "start:dev": "npm run gulp & npm run start:watch",
     "start:watch": "NODE_ENV=development nodemon index.js",
-    "pretest": "npm run lint",
-    "test": "NODE_ENV=test mocha --recursive --compilers ts:ts-node/register,tsx:ts-node/register --require css-modules-require-hook/preset --require jsdom-global/register 'test/**/*.spec.*'",
-    "test:watch": "npm test -- --watch",
-    "lint": "concurrently \"npm run lint:js\" \"npm run lint:ts\"",
-    "lint:js": "standard *.js",
-    "lint:ts": "tslint {src,test}/**/*.{ts,tsx}",
-    "build": "NODE_ENV=production webpack --config=webpack.config.production.js -p --progress",
-    "clean": "rm -rf dist"
+    "gulp": "gulp dev",
+    "start": "NODE_ENV=production node index.js",
+    "build": "NODE_ENV=production webpack --config=webpack.config.production.js -p --progress"
   },
-  "author": "Lu√≠s Rodrigues",
+  "author": "kerbyfc@gmail.com",
   "license": "MIT",
   "devDependencies": {
     "assets-webpack-plugin": "^3.4.0",
@@ -35,6 +29,11 @@
     "expect": "^1.20.2",
     "extract-text-webpack-plugin": "^1.0.1",
     "file-loader": "^0.9.0",
+    "flat": "^2.0.1",
+    "gulp": "^3.9.1",
+    "gulp-rename": "^1.2.2",
+    "gulp-tap": "^0.1.3",
+    "gulp-yaml": "^1.0.1",
     "jsdom": "^9.4.2",
     "jsdom-global": "^2.0.0",
     "mocha": "^3.0.2",
@@ -52,23 +51,28 @@
     "style-loader": "^0.13.1",
     "ts-loader": "^0.8.2",
     "tslint": "^3.14.0",
-    "tslint-loader": "^2.1.5",
     "typescript": "^1.8.10",
+    "typescript-require": "^0.2.9-1",
     "typings": "^1.3.2",
     "webpack": "^1.13.2",
     "webpack-dev-middleware": "^1.6.1",
-    "webpack-hot-middleware": "^2.12.2",
-    "zombie": "^4.2.1"
+    "webpack-hot-middleware": "^2.12.2"
   },
   "dependencies": {
     "babel-polyfill": "^6.13.0",
     "classnames": "^2.2.5",
     "css-modules-require-hook": "^4.0.2",
     "express": "^4.14.0",
+    "gulp-util": "^3.0.7",
     "http-proxy-middleware": "^0.17.1",
+    "inversify": "^2.0.0-rc.13",
     "isomorphic-fetch": "^2.2.1",
+    "isomorphic-style-loader": "^1.0.0",
     "lodash": "^4.15.0",
+    "moment": "^2.14.1",
     "react": "^15.3.1",
+    "react-addons-css-transition-group": "^15.3.1",
+    "react-addons-transition-group": "^15.3.1",
     "react-dom": "^15.3.1",
     "react-helmet": "^3.1.0",
     "react-redux": "^4.4.5",
@@ -77,8 +81,10 @@
     "redux": "^3.5.2",
     "redux-actions": "^0.11.0",
     "redux-saga": "^0.11.0",
+    "reflect-metadata": "^0.1.8",
     "ress": "^1.1.1",
     "serialize-javascript": "^1.3.0",
-    "ts-node": "^1.3.0"
+    "ts-node": "^1.3.0",
+    "typed-css-modules": "^0.1.12"
   }
 }
diff --git a/src/actions/ToggleCheckbox.ts b/src/actions/ToggleCheckbox.ts
new file mode 100644
index 0000000..574de97
--- /dev/null
+++ b/src/actions/ToggleCheckbox.ts
@@ -0,0 +1,20 @@
+import {Action} from '../core/Action';
+import {IRef} from '../core/Ref';
+
+interface IToggleCheckboxPayload {
+  ref: IRef<boolean>;
+  value?: boolean;
+}
+
+export class ToggleCheckbox extends Action<IToggleCheckboxPayload> {
+
+  emit({event, ref}) {
+    const input:HTMLInputElement = <HTMLInputElement>event.target;
+    const value: boolean = input.checked;
+
+    return super.emit({
+      ref,
+      value
+    });
+  }
+}
diff --git a/src/actions/ChangeInputValue.ts b/src/actions/ChangeInputValue.ts
new file mode 100644
index 0000000..760ca35
--- /dev/null
+++ b/src/actions/ChangeInputValue.ts
@@ -0,0 +1,59 @@
+/**
+ * External imports
+ */
+import * as _ from 'lodash';
+
+/**
+ * Local imports
+ */
+import {injectable} from '../core/Injector';
+import {Action} from '../core/Action';
+import {IRef} from '../core/Ref';
+
+export interface IChangeInputValuePayload {
+    event: Event;
+    ref: IRef<string>;
+    selection: number[];
+
+    /**
+     * must be added by action
+     */
+    value?: string;
+    input?: HTMLInputElement;
+}
+
+@injectable()
+export class ChangeInputValue extends Action<IChangeInputValuePayload> {
+
+    emit({event, selection, ref}) {
+        const input: HTMLInputElement = <HTMLInputElement>event.target;
+        const [start, end] = selection;
+
+        const payload = {
+            value: input.value,
+            selection,
+            event,
+            input,
+            ref
+        };
+
+        // TODO: use injector
+        this.actors.push((state) => {
+            /**
+             * Get state value by Ref.path
+             */
+            const stateValue = _.get<string>(state, this.payload.ref.path);
+
+            /**
+             * Check if stateValue was applyed by reducer
+             * and revert input value if not
+             */
+            if (stateValue !== this.payload.value) {
+                this.payload.input.value = stateValue;
+                this.payload.input.setSelectionRange(start, end);
+            }
+        });
+
+        return super.emit(payload);
+    }
+}
diff --git a/src/actions/SaveClient.ts b/src/actions/SaveClient.ts
new file mode 100644
index 0000000..6de2375
--- /dev/null
+++ b/src/actions/SaveClient.ts
@@ -0,0 +1,43 @@
+import {Action} from '../core/Action';
+import {IState} from '../state';
+import {ShowNotification} from './ShowNotification';
+import {NotificationType} from '../vars';
+
+export class ShowClientSaved extends Action<void> {
+
+    constructor() {
+        super();
+
+        // TODO: create actor via DI
+        this.actors.push(this.showSuccessMessage.bind(this));
+    }
+
+    showSuccessMessage() {
+        this.createAction<ShowNotification>(ShowNotification)
+            .emit({
+                text: '–î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã',
+                type: NotificationType.SUCCESS
+            });
+    }
+}
+
+export class SaveClient extends Action<void> {
+
+    constructor() {
+        super();
+
+        // TODO: create actor via DI
+        this.actors.push(this.saveDataToServer.bind(this));
+    }
+
+    saveDataToServer(state: IState) {
+        if (state.clientForm.loading) {
+            // dummy server call
+            setTimeout(() => {
+                this.createAction<ShowClientSaved>(ShowClientSaved).emit(
+                    // here should be server response data
+                );
+            }, 1000);
+        }
+    }
+}
diff --git a/src/actions/SelectOption.ts b/src/actions/SelectOption.ts
new file mode 100644
index 0000000..b4fe720
--- /dev/null
+++ b/src/actions/SelectOption.ts
@@ -0,0 +1,21 @@
+import {Action} from '../core/Action';
+import {IRef} from '../core/Ref';
+
+interface ISelectOptionPayload {
+  ref: IRef<boolean>;
+  value?: string;
+}
+
+export class SelectOption extends Action<ISelectOptionPayload> {
+
+  emit({event, ref}) {
+    const input:HTMLSelectElement = <HTMLSelectElement>event.target;
+    const option: HTMLOptionElement = <HTMLOptionElement>input.selectedOptions[0];
+    const value: string = option.value;
+
+    return super.emit({
+      ref,
+      value
+    });
+  }
+}
diff --git a/src/actions/ShowNotification.ts b/src/actions/ShowNotification.ts
new file mode 100644
index 0000000..12666da
--- /dev/null
+++ b/src/actions/ShowNotification.ts
@@ -0,0 +1,51 @@
+/**
+ * External imports
+ */
+import * as _ from 'lodash';
+
+/**
+ * Local imports
+ */
+import {Action} from '../core/Action';
+import {NotificationType} from '../vars';
+
+/**
+ * Interfaces
+ */
+export interface INotification {
+    text: string;
+    type: NotificationType;
+    delay?: number;
+
+    /**
+     * Should be generated by action
+     * to be able to remove notification by id
+     */
+    id?: string;
+}
+
+export class HideNotificationByTimeOut extends Action<string> {}
+
+export class ShowNotification extends Action<INotification> {
+
+    protected defaultDelay: number = 3500;
+
+    constructor() {
+        super();
+
+        // TODO: create actor via DI
+        this.actors.push(this.hideByTimeout.bind(this));
+    }
+
+    hideByTimeout() {
+        setTimeout(() => {
+            this.createAction<HideNotificationByTimeOut>(HideNotificationByTimeOut)
+                .emit(this.payload.id);
+        }, this.payload.delay || this.defaultDelay);
+    }
+
+    emit(payload: INotification) {
+        payload.id = _.uniqueId('notification');
+        return super.emit(payload);
+    }
+}
diff --git a/src/actions/definition.ts b/src/actions/definition.ts
deleted file mode 100644
index 2db96ad..0000000
--- a/src/actions/definition.ts
+++ /dev/null
@@ -1,10 +0,0 @@
-import { createAction } from "redux-actions";
-
-export const DEFINITION_START = "DEFINITION_START";
-export const definitionStart = createAction(DEFINITION_START);
-
-export const DEFINITION_DONE = "DEFINITION_DONE";
-export const definitionDone = createAction(DEFINITION_DONE);
-
-export const DEFINITION_ERROR = "DEFINITION_ERROR";
-export const definitionError = createAction(DEFINITION_ERROR);
diff --git a/src/actions/search.ts b/src/actions/search.ts
deleted file mode 100644
index 5c3c084..0000000
--- a/src/actions/search.ts
+++ /dev/null
@@ -1,10 +0,0 @@
-import { createAction } from "redux-actions";
-
-export const SEARCH_START = "SEARCH_START";
-export const searchStart = createAction(SEARCH_START);
-
-export const SEARCH_DONE = "SEARCH_DONE";
-export const searchDone = createAction(SEARCH_DONE);
-
-export const SEARCH_ERROR = "SEARCH_ERROR";
-export const searchError = createAction(SEARCH_ERROR);
diff --git a/src/api/DictionaryAPI.ts b/src/api/DictionaryAPI.ts
deleted file mode 100644
index 58517a3..0000000
--- a/src/api/DictionaryAPI.ts
+++ /dev/null
@@ -1,81 +0,0 @@
-import * as fetch from "isomorphic-fetch";
-import { memoize } from "lodash"; // FIXME: Import single function.
-import { createEntry, createEntryStub, IEntry } from "./Entry";
-
-export interface IRawSense {
-  "@ast"?: string;
-  def: string;
-  gramGrp: string;
-  usg?: {
-    "@type": string;
-    "#text": string;
-  };
-}
-
-export interface IRawEntry {
-  "@ast"?: string;
-  "@id": string;
-  "@n"?: string;
-  "@type"?: string;
-  etym?: {
-    "@orig": string;
-    "#text": string;
-  };
-  form: {
-    orth: string;
-    pron?: string;
-  };
-  sense: IRawSense[];
-}
-
-// FIXME: Move to configuration file.
-const rootUrl = "http://localhost:3000/api/search-json";
-
-/**
- * [search description]
- * @param  {string}                         prefix [description]
- * @return {Promise<IEntry[]>}       [description]
- *
- * @todo Plug this into an actual API.
- */
-async function searchFn(prefix: string): Promise<IEntry[]> {
-  const indices = {};
-
-  const response = await fetch(`${rootUrl}?prefix=${prefix}`, { mode: "cors" });
-
-  if (!response.status || response.status.toString().charAt(0) !== "2") {
-    throw new Error(response.statusText);
-  }
-
-  const results = await response.json();
-
-  return results.list.map((entry: string) => {
-    indices[entry] = 1 + (indices[entry] || 0);
-    return createEntryStub(entry, `${entry}:${indices[entry]}`);
-  });
-}
-
-export const search = memoize(searchFn);
-
-/**
- * [define description]
- * @param  {string}                       id [description]
- * @return {Promise<IEntry>}      [description]
- *
- * @todo Plug this into an actual API.
- */
-async function defineFn(id: string): Promise<IEntry[]> {
-  const response = await fetch(`${rootUrl}/${id}`, { mode: "cors" });
-
-  if (!response.status || response.status.toString().charAt(0) !== "2") {
-    throw new Error(response.statusText);
-  }
-
-  const results = await response.json();
-  const entries = results.superEntry ? results.superEntry : [ results ];
-
-  return entries.map((result) =>
-    createEntry(id.split(":")[0], result.entry["@id"], result.entry));
-}
-
-export const define = memoize(defineFn);
diff --git a/src/api/Entry.ts b/src/api/Entry.ts
deleted file mode 100644
index 6813682..0000000
--- a/src/api/Entry.ts
+++ /dev/null
@@ -1,71 +0,0 @@
-import { IRawEntry, IRawSense } from "./DictionaryAPI";
-
-interface ISense {
-  definition: string;
-  grammarGroup: string;
-  usage?: string;
-}
-
-export interface IEntry {
-  etymology?: string;
-  id: string;
-  index: number;
-  pronunciation?: string;
-  raw?: IRawEntry;
-  senses: ISense[];
-  spelling: string;
-  word: string;
-}
-
-function createSense(sense: IRawSense): ISense {
-  return {
-    definition: sense.def,
-    grammarGroup: sense.gramGrp,
-    usage: sense.usg && sense.usg["#text"],
-  };
-}
-
-/**
- * Create an entry stub.
- * @param  {string} word  Entry term.
- * @param  {string} rawId Entry ID.
- * @return {IEntry}       Entry object.
- */
-export function createEntryStub(word: string): IEntry;
-export function createEntryStub(word: string, rawId: string): IEntry;
-export function createEntryStub(word: string, rawId: string = word): IEntry {
-  return {
-    etymology: null,
-    id: rawId,
-    index: 0,
-    pronunciation: null,
-    raw: null,
-    senses: [],
-    spelling: word,
-    word,
-  };
-}
-
-/**
- * Create an entry stub or full entry.
- * @param  {string}    word  Entry term.
- * @param  {string}    rawId Entry ID.
- * @param  {IRawEntry} entry Raw data from the dictionary API.
- * @return {IEntry}          Entry object.
- */
-export function createEntry(word: string, rawId: string = word, entry: IRawEntry): IEntry {
-  if (!entry) {
-    return createEntryStub(word, rawId);
-  }
-
-  return {
-    etymology: entry.etym && entry.etym["#text"],
-    id: entry["@id"] || rawId,
-    index: entry["@n"] && parseInt(entry["@n"], 10),
-    pronunciation: entry.form && entry.form.pron,
-    raw: entry,
-    senses: entry.sense.map(createSense) || [],
-    spelling: entry.form && entry.form.orth || word,
-    word,
-  };
-}
diff --git a/src/components/Button/Button.style.scss b/src/components/Button/Button.style.scss
new file mode 100644
index 0000000..cb5e1cc
--- /dev/null
+++ b/src/components/Button/Button.style.scss
@@ -0,0 +1,7 @@
+.button {
+    composes: bold regular text from "../../styles/typography.scss";
+    composes: rounded outline bordered from "../../styles/effects.scss";
+    padding: .5rem 1rem;
+    background-color: #0275d8;
+    color: white;
+}
diff --git a/src/components/Button/Button.style.scss.d.ts b/src/components/Button/Button.style.scss.d.ts
new file mode 100644
index 0000000..6c9786d
--- /dev/null
+++ b/src/components/Button/Button.style.scss.d.ts
@@ -0,0 +1 @@
+export const button: string;
\ No newline at end of file
diff --git a/src/components/Button/Button.tsx b/src/components/Button/Button.tsx
new file mode 100644
index 0000000..642874f
--- /dev/null
+++ b/src/components/Button/Button.tsx
@@ -0,0 +1,38 @@
+/**
+ * External imports
+ */
+import * as React from 'react';
+import SyntheticEvent = __React.SyntheticEvent;
+
+/**
+ * Local imports
+ */
+import * as styles from './Button.style.scss';
+import {Component} from '../../core/Component';
+
+/**
+ * Interfaces
+ */
+interface IButtonProps {
+    text?: string;
+    onClick: (event: SyntheticEvent) => void
+}
+
+/**
+ * Simple button component
+ */
+export class Button extends Component<IButtonProps, any> {
+
+    onClick = (event) => {
+        event.preventDefault();
+        this.props.onClick(event);
+    };
+
+    render() {
+        return (
+            <button className={this.class(styles.button)} onClick={this.onClick}>
+                {this.props.children || this.props.text}
+            </button>
+        );
+    }
+}
diff --git a/src/components/Checkbox/Checkbox.style.scss b/src/components/Checkbox/Checkbox.style.scss
new file mode 100644
index 0000000..53f3691
--- /dev/null
+++ b/src/components/Checkbox/Checkbox.style.scss
@@ -0,0 +1,20 @@
+.container {
+    composes: container from "../Input/Input.style.scss";
+}
+
+.field {
+    composes: field from "../Input/Input.style.scss";
+    height: 3rem;
+    width: 3rem;
+    -webkit-appearance: initial;
+}
+
+.field:checked:before {
+    content: "‚úì";
+    font-size: 2rem;
+    color: #bddb62;
+    top: -0.6rem;
+    left: -0.4rem;
+    position: relative;
+    font-weight: bold;
+}
diff --git a/src/components/Checkbox/Checkbox.style.scss.d.ts b/src/components/Checkbox/Checkbox.style.scss.d.ts
new file mode 100644
index 0000000..b5214c0
--- /dev/null
+++ b/src/components/Checkbox/Checkbox.style.scss.d.ts
@@ -0,0 +1,2 @@
+export const container: string;
+export const field: string;
\ No newline at end of file
diff --git a/src/components/Checkbox/Checkbox.tsx b/src/components/Checkbox/Checkbox.tsx
new file mode 100644
index 0000000..532eec1
--- /dev/null
+++ b/src/components/Checkbox/Checkbox.tsx
@@ -0,0 +1,38 @@
+/**
+ * External imports
+ */
+import * as React from 'react';
+
+/**
+ * Local imports
+ */
+import {ToggleCheckbox} from '../../actions/ToggleCheckbox';
+import {Component} from '../../core/Component';
+import {IRef} from '../../core/Ref';
+
+/* tslint:disable:no-var-requires */
+const styles = require('./Checkbox.style.scss');
+/* tslint:enable:no-var-requires */
+
+interface ICheckboxProps {
+    $: IRef<boolean>;
+    checked: boolean;
+}
+
+export class Checkbox extends Component<any, any> {
+
+    toggle = (event) => {
+        this.createAction<ToggleCheckbox>(ToggleCheckbox).emit({
+            event, ref: this.props.$
+        })
+    };
+
+    render() {
+        return (
+            <div className={this.class(styles.container)}>
+                <input className={this.class(styles.field)} type="checkbox" checked={this.props.checked} onChange={this.toggle} />
+            </div>
+        );
+    }
+
+}
diff --git a/src/components/EntryDefinition.style.scss b/src/components/EntryDefinition.style.scss
deleted file mode 100644
index 46c8196..0000000
--- a/src/components/EntryDefinition.style.scss
+++ /dev/null
@@ -1,50 +0,0 @@
-.entry {
-  composes: text from "../styles/typography.scss";
-  composes: panel from "../styles/colors.scss";
-  composes: bordered shadowed from "../styles/effects.scss";
-  margin: 0 0 2rem;
-  padding: 1rem;
-}
-
-.title {
-  composes: underlined from "../styles/colors.scss";
-  composes: title from "../styles/typography.scss";
-  margin-bottom: 1rem;
-}
-
-.orth {
-  composes: bold from "../styles/typography.scss";
-}
-
-.n {
-  composes: normal from "../styles/typography.scss";
-}
-
-.pron {
-  composes: regular meta from "../styles/typography.scss";
-
-  &::before {
-    content: " (";
-  }
-
-  &::after {
-    content: ")";
-  }
-}
-
-.senses {
-  list-style: none;
-}
-
-.sense {
-  margin-bottom: 1rem;
-}
-
-.meta {
-  composes: meta text from "../styles/typography.scss";
-  margin-bottom: .5rem;
-}
-
-.gramGrp {
-  margin-right: .25rem;
-}
diff --git a/src/components/EntryDefinition.tsx b/src/components/EntryDefinition.tsx
deleted file mode 100644
index caafc9e..0000000
--- a/src/components/EntryDefinition.tsx
+++ /dev/null
@@ -1,75 +0,0 @@
-import * as React from "react";
-import * as cx from "classnames";
-import "react-dom";
-import { IEntry } from "../api/Entry";
-
-/* tslint:disable:no-var-requires */
-const styles = require("./EntryDefinition.style.scss");
-/* tslint:enable:no-var-requires */
-
-/**
- * Safely transform strings only.
- */
-function stringTransform(token: any, transform: (text: string) => string | string[] | JSX.Element | JSX.Element[]) {
-  return typeof token === "string" ? transform(token) : token;
-}
-
-/**
- * Formats a definition string, adding components where appropriate.
- *
- * @param  {String} text String to format.
- * @return {Array}       Array containing a mixture of strings and React elements.
- */
-function componentizeText(text: string = ""): (string | JSX.Element)[] {
-  return [text]
-    // Replace line breaks:
-    .reduce((all, token) => all.concat(stringTransform(token, t => t.split(/(<br\s*\/?>)/))), [])
-    .map(token => token.match(/<br\s*\/?>/) ? <br /> : token)
-    // Replace underlines:
-    .reduce((all, token) => all.concat(stringTransform(token, t => t.split(/(_[^_]*_)/))), [])
-    .map(token => stringTransform(token, t => t.match(/_.*_/) ? <em>{t.replace(/_/g, "")}</em> : t));
-}
-
-interface IEntryDefinitionProps extends React.Attributes {
-  className?: string;
-  entry?: IEntry;
-  title?: string;
-}
-
-/**
- * Render EntryDefinition component.
- *
- * @param  {IEntryListProps} props Properties.
- * @return {JSX.Element}           Rendered EntryDefinition component.
- */
-const EntryDefinition = (props: IEntryDefinitionProps) => !props.entry ? (
-  <article className={cx(props.className, styles.entry)}>
-    <h2 className={cx(styles.title)}>
-      <span className={cx("orth", styles.orth)}>{props.title}</span>
-    </h2>
-  </article>
-) : (
-  <article className={cx(props.className, styles.entry)}>
-    <h2 className={cx(styles.title)}>
-      <span className={cx("orth", styles.orth)}>{props.entry.spelling}</span>
-      {props.entry.index && <sup className={cx("n", styles.n)}>{props.entry.index}</sup>}
-      {props.entry.pronunciation && <span className={cx("pron", styles.pron)}>{props.entry.pronunciation}</span>}
-    </h2>
-    <ul className={cx("senses", styles.senses)}>
-      {props.entry.senses.map((sense, index) => (
-        <li className={cx("sense", styles.sense)} key={`${props.entry.id}:${index}`}>
-          <div className={cx("meta", styles.meta)}>
-            {sense.grammarGroup && <span className={cx("gramGrp", styles.gramGrp)}>{sense.grammarGroup}</span>}
-            {sense.usage && <span className={cx("usg", styles.usg)}>{sense.usage}</span>}
-          </div>
-          <p className={cx("def", styles.def)}>
-            {componentizeText(sense.definition)}
-          </p>
-        </li>
-      ))}
-    </ul>
-    <p className={cx("etym", styles.etym)}>{componentizeText(props.entry.etymology)}</p>
-  </article>
-);
-
-export default EntryDefinition;
diff --git a/src/components/EntryList.style.scss b/src/components/EntryList.style.scss
deleted file mode 100644
index e2522c6..0000000
--- a/src/components/EntryList.style.scss
+++ /dev/null
@@ -1,9 +0,0 @@
-.list {
-  composes: panel from "../styles/colors.scss";
-  composes: bordered from "../styles/effects.scss";
-
-  list-style: none;
-  margin: 1rem 0 0;
-  padding: 0;
-  width: 100%;
-}
diff --git a/src/components/EntryList.tsx b/src/components/EntryList.tsx
deleted file mode 100644
index 7c869ae..0000000
--- a/src/components/EntryList.tsx
+++ /dev/null
@@ -1,32 +0,0 @@
-import * as React from "react";
-import "react-dom";
-import * as cx from "classnames";
-import EntryListItem from "./EntryListItem";
-import { IEntry } from "../api/Entry";
-
-/* tslint:disable:no-var-requires */
-const styles = require("./EntryList.style.scss");
-/* tslint:enable:no-var-requires */
-
-interface IEntryListProps extends React.Attributes {
-  className?: string;
-  entries: IEntry[];
-}
-
-/**
- * Render EntryList component.
- *
- * @param  {IEntryListProps} props Properties.
- * @return {JSX.Element}           Rendered EntryList component.
- */
-const EntryList = (props: IEntryListProps) => (
-  <ul className={cx(props.className, styles.list)}>
-    {props.entries && props.entries.map(
-      (entry, index) => (
-        <EntryListItem entry={entry} key={entry.id} />
-      )
-    )}
-  </ul>
-);
-
-export default EntryList;
diff --git a/src/components/EntryListItem.style.scss b/src/components/EntryListItem.style.scss
deleted file mode 100644
index 34484b1..0000000
--- a/src/components/EntryListItem.style.scss
+++ /dev/null
@@ -1,16 +0,0 @@
-.item {
-  display: block;
-}
-
-.link {
-  composes: large undecorated text from "../styles/typography.scss";
-  composes: action from "../styles/colors.scss";
-  composes: shadowed outline from "../styles/effects.scss";
-
-  display: block;
-  padding: .5rem 1rem;
-
-  &:focus {
-    padding: calc(.5rem - 2px) calc(1rem - 2px);
-  }
-}
diff --git a/src/components/EntryListItem.tsx b/src/components/EntryListItem.tsx
deleted file mode 100644
index d5b3097..0000000
--- a/src/components/EntryListItem.tsx
+++ /dev/null
@@ -1,33 +0,0 @@
-import * as React from "react";
-import "react-dom";
-import * as cx from "classnames";
-import¬†{ Link } from "react-router";
-import { IEntry } from "../api/Entry";
-
-/* tslint:disable:no-var-requires */
-const styles = require("./EntryListItem.style.scss");
-/* tslint:enable:no-var-requires */
-
-interface IEntryListItemProps extends React.Attributes {
-  className?: string;
-  entry: IEntry;
-}
-
-/**
- * Render EntryListItem component.
- *
- * @param  {IEntryListItemProps} props Properties.
- * @return {JSX.Element}               Rendered EntryListItem component.
- */
-const EntryListItem = (props: IEntryListItemProps) => (
-  <li className={cx(props.className, styles.item)}>
-    <Link
-      className={cx(styles.link)}
-      to={`/define/${props.entry.id}`}
-    >
-      {props.entry.word}
-    </Link>
-  </li>
-);
-
-export default EntryListItem;
diff --git a/src/components/Footer.style.scss b/src/components/Footer.style.scss
deleted file mode 100644
index e69de29..0000000
diff --git a/src/components/Footer.tsx b/src/components/Footer.tsx
deleted file mode 100644
index 400d617..0000000
--- a/src/components/Footer.tsx
+++ /dev/null
@@ -1,15 +0,0 @@
-import * as React from "react";
-import "react-dom";
-
-interface IFooterProps extends React.Attributes {}
-
-/**
- * Render footer container.
- *
- * @return {JSX.Element} Rendered footer container.
- */
-const Footer = (props: IFooterProps) => (
-  <footer className="footer"></footer>
-);
-
-export default Footer;
diff --git a/src/components/Footer/Footer.tsx b/src/components/Footer/Footer.tsx
new file mode 100644
index 0000000..ca1a545
--- /dev/null
+++ b/src/components/Footer/Footer.tsx
@@ -0,0 +1,16 @@
+import * as React from "react";
+import "react-dom";
+
+interface IFooterProps extends React.Attributes {
+}
+
+/**
+ * Render footer container.
+ *
+ * @return {JSX.Element} Rendered footer container.
+ */
+export const Footer = (props:IFooterProps) => (
+    <footer className="footer"></footer>
+);
+
+export default Footer;
diff --git a/src/components/Form/Form.style.scss b/src/components/Form/Form.style.scss
new file mode 100644
index 0000000..e80b292
--- /dev/null
+++ b/src/components/Form/Form.style.scss
@@ -0,0 +1,42 @@
+.form {
+    position: relative;
+}
+
+.fieldset {
+    border: none;
+}
+
+.fieldset[disabled] {
+    opacity: 0.7;
+}
+
+.overlayAppear {
+    opacity: 0.01;
+}
+
+.overlayAppearActive {
+    opacity: 1;
+    transition: opacity 0.2s ease-in;
+}
+
+.overlay {
+    position: absolute;
+    display: block;
+    height: 100%;
+    width: 100%;
+    z-index: 100;
+
+    p {
+        display: table;
+        width: 100%;
+        height: 100%;
+
+        span {
+            opacity: 0.7;
+            font-size: 4rem;
+            display: table-cell;
+            text-align: center;
+            vertical-align: middle;
+        }
+    }
+}
diff --git a/src/components/Form/Form.style.scss.d.ts b/src/components/Form/Form.style.scss.d.ts
new file mode 100644
index 0000000..7a77f08
--- /dev/null
+++ b/src/components/Form/Form.style.scss.d.ts
@@ -0,0 +1,5 @@
+export const form: string;
+export const fieldset: string;
+export const overlayAppear: string;
+export const overlayAppearActive: string;
+export const overlay: string;
\ No newline at end of file
diff --git a/src/components/Form/Form.tsx b/src/components/Form/Form.tsx
new file mode 100644
index 0000000..95602fb
--- /dev/null
+++ b/src/components/Form/Form.tsx
@@ -0,0 +1,51 @@
+/**
+ * External imports
+ */
+import * as React from 'react';
+import * as c from 'classnames';
+import * as ReactCSSTransitionGroup from 'react-addons-css-transition-group';
+
+/**
+ * Local imports
+ */
+import * as styles from './Form.style.scss';
+
+/**
+ * Interfaces
+ */
+interface IFormProps extends React.Attributes {
+    disabled?: boolean;
+    loading?: boolean;
+    children?: any;
+}
+
+export function Form(props: IFormProps) {
+    return (
+        <form className={c(styles.form)}>
+            {props.loading ?
+
+                <ReactCSSTransitionGroup
+                    transitionAppear={true}
+                    transitionAppearTimeout={500}
+                    transitionEnterTimeout={500}
+                    transitionLeaveTimeout={500}
+                    transitionName={{
+                        enter: '', leave: '',
+                        appear: styles.overlayAppear,
+                        appearActive: styles.overlayAppearActive
+                    }}
+                >
+
+                    <div className={c(styles.overlay)}>
+                        <p><span>üïì</span></p>
+                    </div>
+
+                </ReactCSSTransitionGroup>
+            : ''}
+
+            <fieldset disabled={props.disabled || props.loading} className={c(styles.fieldset)}>
+                {props.children}
+            </fieldset>
+        </form>
+    );
+}
diff --git a/src/components/FormRow/FormRow.style.scss b/src/components/FormRow/FormRow.style.scss
new file mode 100644
index 0000000..f25fbef
--- /dev/null
+++ b/src/components/FormRow/FormRow.style.scss
@@ -0,0 +1,10 @@
+$height: 1.3rem;
+
+.title {
+    composes: bold from "../../styles/typography.scss";
+    display: block;
+    height: $height;
+    font-size: 1rem;
+    line-height: $height;
+    padding-left: 0.2rem;
+}
diff --git a/src/components/FormRow/FormRow.style.scss.d.ts b/src/components/FormRow/FormRow.style.scss.d.ts
new file mode 100644
index 0000000..781615d
--- /dev/null
+++ b/src/components/FormRow/FormRow.style.scss.d.ts
@@ -0,0 +1 @@
+export const title: string;
\ No newline at end of file
diff --git a/src/components/FormRow/FormRow.tsx b/src/components/FormRow/FormRow.tsx
new file mode 100644
index 0000000..8e5054c
--- /dev/null
+++ b/src/components/FormRow/FormRow.tsx
@@ -0,0 +1,26 @@
+/**
+ * External imports
+ */
+import * as React from 'react';
+
+/**
+ * Local imports
+ */
+import * as styles from './FormRow.style.scss';
+
+/**
+ * Interfaces
+ */
+interface IFormRowProps extends React.Attributes {
+    title: string
+    children?: any;
+}
+
+export function FormRow(props: IFormRowProps) {
+    return (
+        <div>
+            <label className={styles.title}>{props.title}</label>
+            {props.children}
+        </div>
+    );
+}
diff --git a/src/components/Header.style.scss b/src/components/Header.style.scss
deleted file mode 100644
index 6d433b1..0000000
--- a/src/components/Header.style.scss
+++ /dev/null
@@ -1,5 +0,0 @@
-.title {
-  composes: base centered normal italic from "../styles/typography.scss";
-  composes: embossed from "../styles/effects.scss";
-  margin-bottom: 2rem;
-}
diff --git a/src/components/Header.tsx b/src/components/Header.tsx
deleted file mode 100644
index 4b57832..0000000
--- a/src/components/Header.tsx
+++ /dev/null
@@ -1,26 +0,0 @@
-import * as React from "react";
-import * as cx from "classnames";
-import "react-dom";
-
-/* tslint:disable:no-var-requires */
-const styles = require("./Header.style.scss");
-/* tslint:enable:no-var-requires */
-
-interface IHeaderProps extends React.Attributes {
-  title: string;
-}
-
-/**
- * Render header container.
- *
- * @return {JSX.Element} Rendered header container.
- */
-const Header = (props: IHeaderProps) => (
-  <header className="header">
-    <h1 className={cx(styles.title)}>
-      {props.title}
-    </h1>
-  </header>
-);
-
-export default Header;
diff --git a/src/components/Header/Header.style.scss b/src/components/Header/Header.style.scss
new file mode 100644
index 0000000..72d013e
--- /dev/null
+++ b/src/components/Header/Header.style.scss
@@ -0,0 +1,5 @@
+.title {
+  composes: base centered normal italic from "../../styles/typography.scss";
+  composes: embossed from "../../styles/effects.scss";
+  margin-bottom: 2rem;
+}
diff --git a/src/components/Header/Header.style.scss.d.ts b/src/components/Header/Header.style.scss.d.ts
new file mode 100644
index 0000000..781615d
--- /dev/null
+++ b/src/components/Header/Header.style.scss.d.ts
@@ -0,0 +1 @@
+export const title: string;
\ No newline at end of file
diff --git a/src/components/Header/Header.tsx b/src/components/Header/Header.tsx
new file mode 100644
index 0000000..43cc59b
--- /dev/null
+++ b/src/components/Header/Header.tsx
@@ -0,0 +1,34 @@
+/**
+ * External imports
+ */
+import * as React from "react";
+import * as cx from "classnames";
+import "react-dom";
+
+/**
+ * Local imports
+ */
+import * as styles from './Header.style.scss';
+
+/**
+ * Interfaces
+ */
+interface IHeaderProps extends React.Attributes {
+    title:string;
+}
+
+/**
+ * Render header with title
+ */
+export function Header(props: IHeaderProps) {
+    return (
+        <header className="header">
+            <h1 className={cx(styles.title)}>
+                {props.title}
+            </h1>
+        </header>
+    );
+}
+
+export default Header;
+
diff --git a/src/components/Input/Input.style.scss b/src/components/Input/Input.style.scss
new file mode 100644
index 0000000..c71036b
--- /dev/null
+++ b/src/components/Input/Input.style.scss
@@ -0,0 +1,25 @@
+.container {
+    height: 4.3rem;
+}
+
+.field {
+  composes: large text from "../../styles/typography.scss";
+  composes: field from "../../styles/colors.scss";
+  composes: rounded bordered outline from "../../styles/effects.scss";
+  padding: .5rem 1rem;
+  width: 100%;
+}
+
+.invalid {
+    color: red;
+    .field {
+        border-color: red;
+    }
+}
+
+.error {
+    display: inline-block;
+    height: 1rem;
+    line-height: 1rem;
+    padding-left: 0.5rem;
+}
diff --git a/src/components/Input/Input.style.scss.d.ts b/src/components/Input/Input.style.scss.d.ts
new file mode 100644
index 0000000..2134d7d
--- /dev/null
+++ b/src/components/Input/Input.style.scss.d.ts
@@ -0,0 +1,4 @@
+export const container: string;
+export const field: string;
+export const invalid: string;
+export const error: string;
\ No newline at end of file
diff --git a/src/components/Input/Input.tsx b/src/components/Input/Input.tsx
new file mode 100644
index 0000000..4b0b113
--- /dev/null
+++ b/src/components/Input/Input.tsx
@@ -0,0 +1,213 @@
+/**
+ * External imports
+ */
+import * as React from 'react';
+import * as _ from 'lodash';
+import 'react-dom';
+
+/**
+ * Local imports
+ */
+import * as styles from './Input.style.scss';
+import {ARROW_KEYS} from '../../vars';
+import {Component} from '../../core/Component';
+import {ChangeInputValue} from '../../actions/ChangeInputValue';
+import {IRef} from '../../core/Ref';
+
+/**
+ * Interfaces
+ */
+interface IInputProps {
+    /**
+     * Required
+     */
+    $: IRef<string>;
+
+    // TODO: use val from $
+    // subscribe to ref value change and
+    // update input component with forceUpdate()
+    // Profit:
+    //  1) update only input component, not whole container
+    //  2) no needs to wrap template in container only for input
+    //  3) strict common logic everywhere while scaling
+    //  4) less source code (only <Input $={refs.name} />)
+    val: string;
+
+    /**
+     * Optional
+     */
+    error?: string;
+    mask?: string | boolean;
+    className?: string;
+    delimiter?: string;
+}
+
+interface IInputState {
+    selection: number[];
+    repeat: number;
+}
+
+/**
+ * @note some of handlers are used for mask input
+ * TODO create MaskInput component
+ */
+export class Input extends Component<IInputProps, IInputState> {
+
+    state = {
+        repeat: 0,
+        selection: [0, 0]
+    };
+
+    isMasked() {
+        return this.props.mask !== undefined;
+    }
+
+    select(el: HTMLInputElement, start: number, end: number, direction: number = 1) {
+        start = Math.max(0, start);
+
+        if (el.value.length + 1 <= end) {
+            start = el.value.length - 1;
+        } else {
+            end = start + 1;
+        }
+
+        if (el.value.slice(start, end) === this.props.mask) {
+            (start += direction) && (end += direction);
+        }
+
+        el.setSelectionRange(start, end);
+
+        /**
+         * No needs to use setState to update component
+         */
+        this.state.selection = [start, end];
+    };
+
+    handleChange = (event) => {
+        this.createAction<ChangeInputValue>(ChangeInputValue).emit({
+            event,
+            ref: this.props.$,
+            selection: this.state.selection,
+        });
+    };
+
+    updateSelectionOnMouseUp = (event) => {
+        if (this.isMasked()) {
+            const el = event.target;
+            this.select(el, el.selectionStart, el.selectionStart + 1);
+        }
+    };
+
+    /**
+     * Update mask selection on user input
+     */
+    updateSelectionOnKeyUp = (event) => {
+        if (this.isMasked()) {
+            const el = event.target;
+
+            let direction: number = 1;
+            let {selectionStart: start} = el;
+
+            /**
+             * Support navigation
+             */
+            switch (event.keyCode) {
+                case 37: start -= 1; direction = -1; break;  // up -> start
+                case 38: start = 0; break;
+                case 39: start += 1; break;
+                case 40: start = el.value.length - 1; break; // down -> end
+            }
+
+            this.select(el, start, start + 1, direction);
+        }
+    };
+
+    /**
+     * Do not process arrow navigation on keyDown,
+     * as it will be processed in keyUp event handler
+     */
+    preventOriginArrowNavigation = (event) => {
+        if (this.isMasked()) {
+            if (_.includes(ARROW_KEYS, event.keyCode)) {
+                event.preventDefault();
+            }
+        }
+    };
+
+    preventInputWithoutSelection(event) {
+        if (this.state.selection[1] - this.state.selection[0] !== 1) {
+            event.preventDefault();
+        }
+    }
+
+    handleSelect = (event) => {
+        const el = event.target;
+        let {selectionStart: start, selectionEnd: end} = el;
+
+        /**
+         * No needs to use setState to update component
+         */
+        this.state.selection = [start, end];
+    };
+
+    handleKeyRepeat = (event) => {
+        if (this.isMasked()) {
+            if (this.state.repeat > 1) {
+                event.preventDefault();
+            }
+            /**
+             * No needs to use setState to update component
+             */
+            this.state.repeat = this.state.repeat + 1;
+        }
+    };
+
+    onKeyDown = (event) => {
+        if (this.isMasked()) {
+            this.preventOriginArrowNavigation(event);
+            this.preventInputWithoutSelection(event);
+        }
+    };
+
+    onKeyUp = (event) => {
+        this.updateSelectionOnKeyUp(event);
+        /**
+         * No needs to use setState to update component
+         */
+        this.state.repeat = 0;
+    };
+
+    onMouseUp = (event) => {
+        this.updateSelectionOnMouseUp(event);
+    };
+
+    onKeyPress = (event) => {
+        this.handleKeyRepeat(event);
+    };
+
+    onSelect = (event) => {
+        this.handleSelect(event);
+    };
+
+    onChange = (event) => {
+        this.handleChange(event);
+    };
+
+    render() {
+        return (
+            <div className={this.class(styles.container, this.props.className, (this.props.error && styles.invalid || ''))}>
+                <input type='text'
+                       className={this.class(styles.field)}
+                       value={this.props.val}
+                       onChange={this.onChange}
+                       onSelect={this.onSelect}
+                       onKeyUp={this.onKeyUp}
+                       onKeyDown={this.onKeyDown}
+                       onMouseUp={this.onMouseUp}
+                       onKeyPress={this.onKeyPress}
+                />
+                <span className={styles.error}>{this.props.error}</span>
+            </div>
+        )
+    }
+}
diff --git a/src/components/Input/MaskedInput/MaskedInput.tsx b/src/components/Input/MaskedInput/MaskedInput.tsx
new file mode 100644
index 0000000..e69de29
diff --git a/src/components/LoadingIndicator.style.scss b/src/components/LoadingIndicator.style.scss
deleted file mode 100644
index 5d61b26..0000000
--- a/src/components/LoadingIndicator.style.scss
+++ /dev/null
@@ -1,46 +0,0 @@
-.loader:before,
-.loader:after,
-.loader {
-  border-radius: 50%;
-  width: 1rem;
-  height: 1rem;
-  animation-fill-mode: both;
-  animation: loader 2s infinite ease-in-out;
-}
-
-.loader {
-  composes: loader from "../styles/colors.scss";
-  font-size: 10px;
-  margin: 5rem auto;
-  position: relative;
-  text-indent: -9999em;
-  transform: translateZ(0);
-  animation-delay: -0.16s;
-}
-
-.loader:before {
-  left: -3.5rem;
-  animation-delay: -0.32s;
-}
-
-.loader:after {
-  left: 3.5rem;
-}
-
-.loader:before,
-.loader:after {
-  content: '';
-  position: absolute;
-  top: 0;
-}
-
-@keyframes loader {
-  0%,
-  80%,
-  100% {
-    box-shadow: 0 1rem 0 -0.7rem;
-  }
-  40% {
-    box-shadow: 0 1rem 0 0;
-  }
-}
diff --git a/src/components/LoadingIndicator.tsx b/src/components/LoadingIndicator.tsx
deleted file mode 100644
index 880b379..0000000
--- a/src/components/LoadingIndicator.tsx
+++ /dev/null
@@ -1,22 +0,0 @@
-import * as React from "react";
-import * as cx from "classnames";
-import "react-dom";
-
-/* tslint:disable:no-var-requires */
-const styles = require("./LoadingIndicator.style.scss");
-/* tslint:enable:no-var-requires */
-
-interface ILoadingIndicatorProps extends React.Attributes {
-  className?: string;
-}
-
-/**
- * Render footer container.
- *
- * @return {JSX.Element} Rendered footer container.
- */
-const LoadingIndicator = (props: ILoadingIndicatorProps) => (
-  <div className={cx(styles.loader, props.className)}>A carregar...</div>
-);
-
-export default LoadingIndicator;
diff --git a/src/components/Nodification/Notification.style.scss b/src/components/Nodification/Notification.style.scss
new file mode 100644
index 0000000..12fb771
--- /dev/null
+++ b/src/components/Nodification/Notification.style.scss
@@ -0,0 +1,14 @@
+.container {
+    composes: rounded bordered from "../../styles/effects.scss";
+    max-width: 25rem;
+    padding: 1rem;
+    margin: 1rem 0;
+}
+
+.success {
+    background: #dff0d8;
+}
+
+.error {
+    background: #f2dede;
+}
diff --git a/src/components/Nodification/Notification.style.scss.d.ts b/src/components/Nodification/Notification.style.scss.d.ts
new file mode 100644
index 0000000..9013bc0
--- /dev/null
+++ b/src/components/Nodification/Notification.style.scss.d.ts
@@ -0,0 +1,3 @@
+export const container: string;
+export const success: string;
+export const error: string;
\ No newline at end of file
diff --git a/src/components/Nodification/Notification.tsx b/src/components/Nodification/Notification.tsx
new file mode 100644
index 0000000..8410c0e
--- /dev/null
+++ b/src/components/Nodification/Notification.tsx
@@ -0,0 +1,29 @@
+/**
+ * External imports
+ */
+import * as React from 'react';
+import * as c from 'classnames';
+
+/**
+ * Local imports
+ */
+import * as styles from './Notification.style.scss';
+import {INotification} from '../../actions/ShowNotification';
+import {NotificationType} from '../../vars';
+
+/**
+ * Interfaces
+ */
+interface INotificationProps extends React.Attributes, INotification {}
+
+export function Notification(props: INotificationProps) {
+
+    const modifier: string = props.type === NotificationType.SUCCESS ?
+        styles.success : styles.error;
+
+    return (
+        <div className={c(styles.container, modifier)}>
+            {props.text}
+        </div>
+    );
+}
diff --git a/src/components/SearchInput.style.scss b/src/components/SearchInput.style.scss
deleted file mode 100644
index 80dfcae..0000000
--- a/src/components/SearchInput.style.scss
+++ /dev/null
@@ -1,70 +0,0 @@
-.container {
-  height: 4rem;
-}
-
-.field {
-  composes: large text from "../styles/typography.scss";
-  composes: field from "../styles/colors.scss";
-  composes: rounded bordered outline from "../styles/effects.scss";
-  padding: .5rem 1rem;
-  width: 100%;
-}
-
-.loading {
-  padding-right: 4rem;
-}
-
-.loaderContainer {
-  left: calc(100% - 3.75rem);
-  height: 2.5rem;
-  padding: .5rem 0 .5rem 1rem;
-  position: relative;
-  top: -2.75rem;
-  width: 2.5rem;
-}
-
-.loader:before,
-.loader:after,
-.loader {
-  border-radius: 50%;
-  width: .5rem;
-  height: .5rem;
-  animation-fill-mode: both;
-  animation: loader 2s infinite ease-in-out;
-}
-
-.loader {
-  composes: loader from "../styles/colors.scss";
-  margin: 0;
-  position: relative;
-  text-indent: -9999em;
-  transform: translateZ(0);
-  animation-delay: -0.16s;
-}
-
-.loader:before {
-  left: -.75rem;
-  animation-delay: -0.32s;
-}
-
-.loader:after {
-  left: .75rem;
-}
-
-.loader:before,
-.loader:after {
-  content: '';
-  position: absolute;
-  top: 0;
-}
-
-@keyframes loader {
-  0%,
-  80%,
-  100% {
-    box-shadow: 0 .5rem 0 -0.7rem;
-  }
-  40% {
-    box-shadow: 0 .5rem 0 0;
-  }
-}
diff --git a/src/components/SearchInput.tsx b/src/components/SearchInput.tsx
deleted file mode 100644
index ae307dd..0000000
--- a/src/components/SearchInput.tsx
+++ /dev/null
@@ -1,47 +0,0 @@
-import * as React from "react";
-import * as cx from "classnames";
-import LoadingIndicator from "./LoadingIndicator";
-import "react-dom";
-
-/* tslint:disable:no-var-requires */
-const styles = require("./SearchInput.style.scss");
-/* tslint:enable:no-var-requires */
-
-interface ISearchInputProps extends React.Attributes {
-  className?: string;
-  isLoading?: boolean;
-  placeholder?: string;
-  text?: string;
-  onChange?(event: React.FormEvent): void;
-  onSubmit?(prefix: String): void;
-}
-
-/**
- * Render application container.
- *
- * @return {JSX.Element} Rendered application container.
- */
-const SearchInput = (props: ISearchInputProps) => (
-  <div className={cx(styles.container, props.className)}>
-    <input
-      autoFocus
-      type="search"
-      className={cx(styles.field, props.isLoading && styles.loading)}
-      value={props.text}
-      onChange={props.onChange}
-      onKeyUp={(event) => {
-        if (event.keyCode === 13) {
-          props.onSubmit(props.text);
-        }
-      }}
-      placeholder={props.placeholder}
-    />
-    {props.isLoading ? (
-      <div className={styles.loaderContainer}>
-        <LoadingIndicator className={styles.loader} />
-      </div>
-    ) : ""}
-  </div>
-);
-
-export default SearchInput;
diff --git a/src/components/Select/Select.style.scss b/src/components/Select/Select.style.scss
new file mode 100644
index 0000000..d36d96c
--- /dev/null
+++ b/src/components/Select/Select.style.scss
@@ -0,0 +1,8 @@
+.container {
+    composes: container from "../Input/Input.style.scss";
+}
+
+.field {
+    composes: field from "../Input/Input.style.scss";
+    -webkit-appearance: initial;
+}
diff --git a/src/components/Select/Select.style.scss.d.ts b/src/components/Select/Select.style.scss.d.ts
new file mode 100644
index 0000000..b5214c0
--- /dev/null
+++ b/src/components/Select/Select.style.scss.d.ts
@@ -0,0 +1,2 @@
+export const container: string;
+export const field: string;
\ No newline at end of file
diff --git a/src/components/Select/Select.tsx b/src/components/Select/Select.tsx
new file mode 100644
index 0000000..64bb959
--- /dev/null
+++ b/src/components/Select/Select.tsx
@@ -0,0 +1,43 @@
+/**
+ * External imports
+ */
+import * as React from 'react';
+import * as cx from 'classnames';
+
+/**
+ * Local imports
+ */
+import {Component} from '../../core/Component';
+import {SelectOption} from '../../actions/SelectOption';
+import {IRef} from '../../core/Ref';
+
+/* tslint:disable:no-var-requires */
+const styles = require('./Select.style.scss');
+/* tslint:enable:no-var-requires */
+
+interface ICheckboxProps {
+    $: IRef<boolean>;
+    value: string;
+}
+
+export class Select extends Component<any, any> {
+
+    toggle = (event) => {
+        this.createAction<SelectOption>(SelectOption).emit({
+            event, ref: this.props.$
+        });
+    };
+
+    render() {
+        return (
+            <div className={cx(styles.container)}>
+                <select className={cx(styles.field)} onChange={this.toggle} value={this.props.value}>
+                    {(this.props.options || []).map((option) => {
+                        return <option key={option} value={option}>{option}</option>;
+                    })}
+                </select>
+            </div>
+        );
+    }
+
+}
diff --git a/src/components/Warning.style.scss b/src/components/Warning.style.scss
deleted file mode 100644
index e69de29..0000000
diff --git a/src/components/Warning.tsx b/src/components/Warning.tsx
deleted file mode 100644
index 084cb67..0000000
--- a/src/components/Warning.tsx
+++ /dev/null
@@ -1,19 +0,0 @@
-import * as React from "react";
-import "react-dom";
-
-interface IWarningProps extends React.Attributes {
-  message?: string;
-}
-
-/**
- * Render warning component.
- *
- * @return {JSX.Element} Rendered warning component.
- */
-const Warning = (props: IWarningProps) => (
-  <div className="error">
-    <div className="message">{props.message || "Erro"}</div>
-  </div>
-);
-
-export default Warning;
diff --git a/src/containers/App.style.scss b/src/containers/App.style.scss
deleted file mode 100644
index 96ef81c..0000000
--- a/src/containers/App.style.scss
+++ /dev/null
@@ -1,5 +0,0 @@
-.app {
-  width: 30rem;
-  margin: 0 auto;
-  padding: 2rem;
-}
diff --git a/src/containers/App.tsx b/src/containers/App.tsx
deleted file mode 100644
index b52e4aa..0000000
--- a/src/containers/App.tsx
+++ /dev/null
@@ -1,28 +0,0 @@
-import * as React from "react";
-import "react-dom";
-import * as cx from "classnames";
-import Footer from "../components/Footer";
-import Header from "../components/Header";
-
-/* tslint:disable:no-var-requires */
-const styles = require("./App.style.scss");
-/* tslint:enable:no-var-requires */
-
-interface IAppProps extends React.ClassAttributes<App> {}
-
-export default class App extends React.Component<IAppProps, {}> {
-  /**
-   * Render application container.
-   *
-   * @return {JSX.Element} Rendered application container.
-   */
-  public render() {
-    return (
-      <div className={cx("dictionary-app", styles.app)}>
-        <Header title="Dicion√°rio" />
-        {this.props.children}
-        <Footer />
-      </div>
-    );
-  }
-}
diff --git a/src/containers/App/App.style.scss b/src/containers/App/App.style.scss
new file mode 100644
index 0000000..96ef81c
--- /dev/null
+++ b/src/containers/App/App.style.scss
@@ -0,0 +1,5 @@
+.app {
+  width: 30rem;
+  margin: 0 auto;
+  padding: 2rem;
+}
diff --git a/src/containers/App/App.style.scss.d.ts b/src/containers/App/App.style.scss.d.ts
new file mode 100644
index 0000000..6868c03
--- /dev/null
+++ b/src/containers/App/App.style.scss.d.ts
@@ -0,0 +1 @@
+export const app: string;
\ No newline at end of file
diff --git a/src/containers/App/App.tsx b/src/containers/App/App.tsx
new file mode 100644
index 0000000..48a750c
--- /dev/null
+++ b/src/containers/App/App.tsx
@@ -0,0 +1,34 @@
+/**
+ * External imports
+ */
+import * as React from 'react';
+import 'react-dom';
+
+/**
+ * Local imports
+ */
+import * as styles from './App.style.scss';
+import Footer from '../../components/Footer/Footer';
+import Header from '../../components/Header/Header';
+import Component from '../../core/Component';
+import {Notifier} from '../Notifier/Notifier';
+
+/**
+ * Main application container
+ */
+export class App extends Component<{}, {}> {
+
+    public render() {
+        return (
+            <div className={styles.app}>
+                <Header title='Virtu'/>
+                {this.props.children}
+                <Footer />
+
+                <Notifier />
+            </div>
+        );
+    }
+}
+
+export default App;
diff --git a/src/containers/ClientForm/ClientForm.tsx b/src/containers/ClientForm/ClientForm.tsx
new file mode 100644
index 0000000..3bf6cae
--- /dev/null
+++ b/src/containers/ClientForm/ClientForm.tsx
@@ -0,0 +1,99 @@
+/**
+ * External imports
+ */
+import * as React from 'react';
+import {connect} from 'react-redux';
+
+/**
+ * Local imports
+ */
+import {Component} from '../../core/Component';
+import {FormRow} from '../../components/FormRow/FormRow';
+import {Input} from '../../components/Input/Input';
+import {Checkbox} from '../../components/Checkbox/Checkbox';
+import {Select} from '../../components/Select/Select';
+import {IState, IClientForm, IClientFormRef} from '../../state';
+import {Button} from '../../components/Button/Button';
+import {SaveClient} from '../../actions/SaveClient';
+import {Form} from '../../components/Form/Form';
+
+/**
+ * Constants
+ * TODO: fetch it
+ */
+const carMarks = [
+    '', 'mazda', 'ford', 'audi'
+];
+
+const carModels = {
+    mazda: ['', '3', '6', 'mpv'],
+    ford: ['', 'focus', 'mustang', 'mondeo'],
+    audi: ['', 'A3', 'A6', 'A8']
+};
+
+/**
+ * Redux
+ */
+function mapStateToProps(state: IState) {
+    return state.clientForm;
+}
+
+/**
+ * Form to add client to database
+ */
+@connect(mapStateToProps)
+export class ClientForm extends Component<IClientForm, any> {
+
+    save = (event) => {
+        this.createAction<SaveClient>(SaveClient).emit();
+    };
+
+    render() {
+        const refs: IClientFormRef = this.$.clientForm;
+
+        return (
+            <Form loading={this.props.loading}>
+
+                <FormRow title="–§–∞–º–∏–ª–∏—è">
+                    <Input key="surname" val={this.props.data.surname} $={refs.data.surname} />
+                </FormRow>
+
+                <FormRow title="–ò–º—è">
+                    <Input key="name" val={this.props.data.name} $={refs.data.name} />
+                </FormRow>
+
+                <FormRow title="–û—Ç—á–µ—Å—Ç–≤–æ">
+                    <Input key="middlename" val={this.props.data.middlename} $={refs.data.middlename} />
+                </FormRow>
+
+                <FormRow title="–î–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è">
+                    <Input key="birthday" val={this.props.data.birthday} $={refs.data.birthday} mask="." />
+                </FormRow>
+
+                <FormRow title="–°–µ—Ä–∏—è –∏ –Ω–æ–º–µ—Ä –ø–∞—Å–ø–æ—Ä—Ç–∞">
+                    <Input key="passport" val={this.props.data.passport} $={refs.data.passport} mask=" " />
+                </FormRow>
+
+                <FormRow title="–ü–æ—á—Ç–∞">
+                    <Input key="email" val={this.props.data.email} $={refs.data.email} error={this.props.errors.email} />
+                </FormRow>
+
+                <FormRow title="–ê–≤—Ç–æ–º–æ–±–∏–ª—å">
+                    <Checkbox key="hascar" checked={this.props.data.car.exists} $={refs.data.car.exists} />
+                </FormRow>
+
+                {this.props.data.car.exists? (() => (<FormRow title="–ú–∞—Ä–∫–∞ –∞–≤—Ç–æ–º–æ–±–∏–ª—è">
+                    <Select key="carMark" options={carMarks} value={this.props.data.car.brand} $={refs.data.car.brand} />
+                </FormRow>))() : ''}
+
+                {this.props.data.car.exists ? (() => (<FormRow title="–ú–æ–¥–µ–ª—å –∞–≤—Ç–æ–º–æ–±–∏–ª—è">
+                    <Select key="carModel" options={carModels[this.props.data.car.brand]} value={this.props.data.car.model} $={refs.data.car.model} />
+                </FormRow>))() : ''}
+
+                <Button onClick={this.save}>
+                    –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
+                </Button>
+            </Form>
+        );
+    }
+}
diff --git a/src/containers/Definition.tsx b/src/containers/Definition.tsx
deleted file mode 100644
index 871b2d0..0000000
--- a/src/containers/Definition.tsx
+++ /dev/null
@@ -1,95 +0,0 @@
-import * as React from "react";
-import "react-dom";
-import * as Helmet from "react-helmet";
-import { connect } from "react-redux";
-import { definitionStart } from "../actions/definition";
-import { definitionTask } from "../sagas/definition";
-import { IEntry } from "../api/Entry";
-import LoadingIndicator from "../components/LoadingIndicator";
-import Warning from "../components/Warning";
-import EntryDefinition from "../components/EntryDefinition";
-
-interface IDefinitionProps extends React.ClassAttributes<Definition> {
-  entries?: IEntry[];
-  error?: Error & { message: string };
-  id?: string;
-  isLoading?: boolean;
-  onLoad?: (id: string) => void;
-  params?: {
-    id?: string;
-  };
-}
-
-class Definition extends React.Component<IDefinitionProps, {}> {
-  /**
-   * Definition data preloaders.
-   *
-   * @param  {Function} dispatch  Redux action dispatcher.
-   * @param  {String}   params.id Entry ID.
-   * @return {Array}              Saga workers and action objects.
-   */
-  public static preload({ id }) {
-    return [
-      [definitionTask, definitionStart(id)],
-    ];
-  }
-
-  /**
-   * Triggers onLoad property on mount.
-   *
-   * @return {void}
-   */
-  public componentDidMount() {
-    if (this.props.id) {
-      this.props.onLoad(this.props.id);
-    }
-  }
-
-  /**
-   * Render search container.
-   *
-   * @return {JSX.Element} Rendered search container.
-   */
-  public render() {
-    let title: string;
-    let content: JSX.Element | JSX.Element[] | string;
-
-    if (this.props.isLoading) {
-      title = "A carregar...";
-      content = <LoadingIndicator />;
-
-    } else if (this.props.error) {
-      title = this.props.error.message;
-      content = <Warning message={this.props.error.message} />;
-
-    } else if (!this.props.entries || !this.props.entries.length) {
-      title = "Palavra n√£o encontrada";
-      content = <Warning message="Palavra n√£o encontrada" />;
-
-    } else {
-      title = this.props.id && this.props.id.replace(/:\d+$/, "");
-      content = this.props.entries.map(entry => (
-        <EntryDefinition key={entry.id} title={entry.word} entry={entry} />
-      ));
-    }
-
-    return (
-      <section className="definition">
-        <Helmet title={title} />
-        {content}
-      </section>
-    );
-  }
-}
-
-export default connect(
-  (state, props: any) => ({
-    entries: state.definition.entries,
-    error: state.definition.error,
-    id: state.definition.id || props.params && props.params.id,
-    isLoading: state.definition.isLoading,
-  }),
-  (dispatch) => ({
-    onLoad: id => dispatch(definitionStart(id)),
-  })
-)(Definition as React.ComponentClass<any>);
diff --git a/src/containers/Document.tsx b/src/containers/Document.tsx
deleted file mode 100644
index 7df415e..0000000
--- a/src/containers/Document.tsx
+++ /dev/null
@@ -1,62 +0,0 @@
-import * as React from "react";
-import "react-dom";
-import { renderToString } from "react-dom/server";
-import * as Helmet from "react-helmet";
-import serialize = require("serialize-javascript");
-
-interface IDocumentProps extends React.ClassAttributes<Document> {
-  app?: JSX.Element;
-  assets?: Object;
-  server?: Boolean;
-  store: any;
-}
-
-/**
- * Document component class.
- *
- * This class is to be used for server-side rendering only. A boolean
- * `server` property has been supplied to prevent `Helmet.rewind()` from
- * running during tests.
- */
-export default class Document extends React.Component<IDocumentProps, {}> {
-  /**
-   * Render document for the server.
-   *
-   * @return {JSX.Element} Rendered document.
-   */
-  public render() {
-    const app = this.props.app ? renderToString(this.props.app) : "";
-    const assets = this.props.assets || {};
-    const state = this.props.store.getState();
-    // Helmet.rewind() must be called after ReactDOMServer.renderToString():
-    const head = this.props.server ? Helmet.rewind() : null;
-    const fonts = "https://fonts.googleapis.com/css?family=Playfair+Display:400,400italic,700,700italic";
-
-    return (
-      <html>
-        <head>
-          {head && head.title.toComponent()}
-          <meta name="viewport" content="width=device-width, initial-scale=1" />
-          <link rel="shortcut icon" href="/favicon.ico" />
-          {assets && Object.keys(assets).filter(chunk => !!assets[chunk].css).map(chunk => (
-            <link key={`asset.${chunk}.css`} href={assets[chunk].css} rel="stylesheet" type="text/css" />
-          ))}
-          <link href={fonts} rel="stylesheet" type="text/css" />
-        </head>
-        <body>
-          <div
-            className="dictionary"
-            id="root"
-            dangerouslySetInnerHTML={{__html: app}}
-          />
-          <script id="preloaded" type="text/javascript" dangerouslySetInnerHTML={{
-            __html: `window.__PRELOADED__=${serialize(state)};`,
-          }} />
-          {assets && Object.keys(assets).filter(chunk => !!assets[chunk].js).map(chunk => (
-            <script key={`asset.${chunk}.js`} src={assets[chunk].js} type="text/javascript" />
-          ))}
-        </body>
-      </html>
-    );
-  }
-}
diff --git a/src/containers/Document/Document.tsx b/src/containers/Document/Document.tsx
new file mode 100644
index 0000000..daf8d67
--- /dev/null
+++ b/src/containers/Document/Document.tsx
@@ -0,0 +1,64 @@
+import * as React from "react";
+import "react-dom";
+import { renderToString } from "react-dom/server";
+import * as Helmet from "react-helmet";
+import serialize = require("serialize-javascript");
+
+interface IDocumentProps extends React.ClassAttributes<Document> {
+  app?: JSX.Element;
+  assets?: Object;
+  server?: Boolean;
+  store: any;
+}
+
+const css = [];
+
+/**
+ * Document component class.
+ *
+ * This class is to be used for server-side rendering only. A boolean
+ * `server` property has been supplied to prevent `Helmet.rewind()` from
+ * running during tests.
+ */
+export default class Document extends React.Component<IDocumentProps, {}> {
+
+  /**
+   * Render document for the server.
+   *
+   * @return {JSX.Element} Rendered document.
+   */
+  public render() {
+    const app = this.props.app ? renderToString(this.props.app) : "";
+    const assets = this.props.assets || {};
+    const state = this.props.store.getState();
+    const head = this.props.server ? Helmet.rewind() : null;
+    const fonts = "https://fonts.googleapis.com/css?family=Playfair+Display:400,400italic,700,700italic";
+
+    return (
+      <html>
+        <head>
+          {head && head.title.toComponent()}
+          <meta name="viewport" content="width=device-width, initial-scale=1" />
+          <link rel="shortcut icon" href="/favicon.ico" />
+          {assets && Object.keys(assets).filter(chunk => !!assets[chunk].css).map(chunk => (
+            <link key={`asset.${chunk}.css`} href={assets[chunk].css} rel="stylesheet" type="text/css" />
+          ))}
+          <link href={fonts} rel="stylesheet" type="text/css" />
+        </head>
+        <body>
+          <div
+            className="app"
+            id="root"
+            dangerouslySetInnerHTML={{__html: app}}
+          />
+          <script id="preloaded" type="text/javascript" dangerouslySetInnerHTML={{
+            __html: `window.__PRELOADED__=${serialize(state)};`,
+          }} />
+          {assets && Object.keys(assets).filter(chunk => !!assets[chunk].js).map(chunk => (
+            <script key={`asset.${chunk}.js`} src={assets[chunk].js} type="text/javascript" />
+          ))}
+        </body>
+      </html>
+    );
+  }
+}
diff --git a/src/containers/Notifier/Notifier.style.scss b/src/containers/Notifier/Notifier.style.scss
new file mode 100644
index 0000000..3307075
--- /dev/null
+++ b/src/containers/Notifier/Notifier.style.scss
@@ -0,0 +1,5 @@
+.container {
+    position: fixed;
+    top: 2rem;
+    right: 2rem;
+}
diff --git a/src/containers/Notifier/Notifier.style.scss.d.ts b/src/containers/Notifier/Notifier.style.scss.d.ts
new file mode 100644
index 0000000..f0ae2ea
--- /dev/null
+++ b/src/containers/Notifier/Notifier.style.scss.d.ts
@@ -0,0 +1 @@
+export const container: string;
\ No newline at end of file
diff --git a/src/containers/Notifier/Notifier.tsx b/src/containers/Notifier/Notifier.tsx
new file mode 100644
index 0000000..01abddc
--- /dev/null
+++ b/src/containers/Notifier/Notifier.tsx
@@ -0,0 +1,50 @@
+/**
+ * External imports
+ */
+import * as React from 'react';
+import * as _ from 'lodash';
+import {connect} from 'react-redux';
+
+/**
+ * Local imports
+ */
+import * as styles from './Notifier.style.scss';
+import {Component} from '../../core/Component';
+import {IState} from '../../state';
+import {Notification} from '../../components/Nodification/Notification';
+import {INotification} from '../../actions/ShowNotification';
+
+/**
+ * Redux
+ */
+function mapStateToProps(state: IState) {
+    return {
+        notifications: state.notifications
+    };
+}
+
+/**
+ * Interfaces
+ */
+interface INotifierProps {
+    notifications?: INotification[]
+}
+
+@connect(mapStateToProps)
+export class Notifier extends Component<INotifierProps, any> {
+
+    render() {
+        return (
+            <div className={styles.container}>
+                {_.map(this.props.notifications, (notification: INotification) => {
+                    return <Notification
+                        key={notification.id}
+                        type={notification.type}
+                        text={notification.text}
+                        id={notification.id}
+                    />;
+                })}
+            </div>
+        );
+    }
+}
diff --git a/src/containers/Search.tsx b/src/containers/Search.tsx
deleted file mode 100644
index c084d8b..0000000
--- a/src/containers/Search.tsx
+++ /dev/null
@@ -1,109 +0,0 @@
-import * as React from "react";
-import "react-dom";
-import * as Helmet from "react-helmet";
-import { connect } from "react-redux";
-import { push } from "react-router-redux";
-import { searchStart } from "../actions/search";
-import { searchTask } from "../sagas/search";
-import { IEntry } from "../api/Entry";
-import EntryList from "../components/EntryList";
-import Warning from "../components/Warning";
-import SearchInput from "../components/SearchInput";
-
-export interface ISearchProps extends React.ClassAttributes<any> {
-  entries?: IEntry[];
-  error?: Error & { message: string };
-  isLoading?: boolean;
-  onChange: (event: React.FormEvent) => void;
-  onLoad: (prefix: string) => void;
-  onSubmit: (prefix: string) => void;
-  params?: {
-    prefix?: string;
-  };
-  prefix?: string;
-}
-
-class Search extends React.Component<ISearchProps, {}> {
-  /**
-   * Search results data preloaders.
-   *
-   * @param  {string} params.prefix Search term prefix.
-   * @return {Array}                Saga workers and action objects.
-   */
-  public static preload({ prefix }) {
-    return [
-      [searchTask, searchStart(prefix)],
-    ];
-  }
-
-  /**
-   * If set, fetch search results from `prefix` parameter on mount.
-   */
-  public componentDidMount() {
-    if (this.props.prefix) {
-      this.props.onLoad(this.props.prefix);
-    }
-  }
-
-  /**
-   * Render search container.
-   *
-   * @return {JSX.Element} Rendered search container.
-   */
-  public render() {
-    const prefix = this.props.prefix || "";
-    let title: string = "Dicion√°rio";
-    let content: JSX.Element | JSX.Element[] | string = null;
-
-    if (prefix.length) {
-
-      if (!this.props.isLoading) {
-        if (this.props.error) {
-          title = this.props.error.message;
-          content = <Warning message={this.props.error.message} />;
-
-        } else if (!this.props.entries || !this.props.entries.length) {
-          title = "Palavra n√£o encontrada";
-          content = <Warning message="Palavra n√£o encontrada" />;
-        }
-      }
-
-      if (!content) {
-        title = `Pesquisa por ${prefix}`;
-        content = <EntryList entries={this.props.entries} />;
-      }
-    }
-
-    if (this.props.isLoading) {
-      title = "A pesquisar...";
-    }
-
-    return (
-      <section className="search">
-        <Helmet title={title} />
-        <SearchInput
-          isLoading={prefix.length && this.props.isLoading}
-          onChange={this.props.onChange}
-          onSubmit={this.props.onSubmit}
-          placeholder="Indique a palavra a pesquisar"
-          text={prefix}
-        />
-        {content}
-      </section>
-    );
-  }
-}
-
-export default connect(
-  (state, props: any) => ({
-    entries: state.search.entries,
-    error: state.search.error,
-    isLoading: state.search.isLoading,
-    prefix: state.search.prefix !== null ? state.search.prefix : props.params && props.params.prefix,
-  }),
-  (dispatch) => ({
-    onChange: (event) => dispatch(searchStart(event.target.value)),
-    onLoad: (prefix) => dispatch(searchStart(prefix)),
-    onSubmit: (prefix) => dispatch(push("/search/" + prefix)),
-  })
-)(Search as React.ComponentClass<any>);
diff --git a/src/core/Action.ts b/src/core/Action.ts
new file mode 100644
index 0000000..5bd6bf7
--- /dev/null
+++ b/src/core/Action.ts
@@ -0,0 +1,112 @@
+/**
+ * Local imports
+ */
+import {injectable, injector} from './Injector';
+import {Dispatcher} from './Dispatcher';
+
+export interface IAction<TPayload> {
+    type: string;
+    emit(payload: TPayload): boolean;
+}
+
+export interface IDispatcherAction {
+    is: Action<any>,
+    type: string;
+    class: Function;
+    __payload: any;
+}
+
+@injectable()
+export class Action<TPayload> implements IAction<TPayload> {
+
+    /**
+     * Static
+     */
+
+    static getPayload<TPayload>(action: IDispatcherAction): TPayload {
+        return <TPayload>action.__payload;
+    }
+
+    static resolveType(): string {
+        return this.name || this.toString().match(/function ([^\(]+)/)[1];
+    }
+
+    static get type(): string {
+        return this.resolveType();
+    }
+
+    /**
+     * Properties
+     */
+
+    protected actors: any[] = [];
+    protected emitted = false;
+    protected payload: TPayload = null;
+    protected dispatcher: Dispatcher;
+
+    constructor() {
+        this.dispatcher = injector.get(Dispatcher);
+    }
+
+    /**
+     * Interface
+     */
+
+    get type() {
+        return Action.resolveType.call(this.constructor);
+    }
+
+    shouldBeEmitted(): boolean {
+        return true;
+    }
+
+    emit(payload?: TPayload): boolean {
+        this.payload = payload || null;
+
+        // TODO: check environment
+        if (this.emitted) {
+            throw new Error(`Action can be emitted only once (${this.type})`);
+        }
+
+        /**
+         * The prefer way to detect actions in reducers is by 'is' prop,
+         * as it gives an ability to use prototype chain
+         *
+         * @example in reducer
+         *   if (action.is instanceof KeyboardAction) {
+         *      const payload = KeyboardAction.getPayload<KeyboardActionPayload>();
+         */
+        const data = {
+            is: this,
+            type: this.type,
+            class: this.constructor,
+            __payload: this.payload,
+        };
+
+        /**
+         * Each actor should be envoked once after reducing
+         */
+        if (this.actors.length) {
+            let actor;
+            while (actor = this.actors.shift()) {
+                this.dispatcher.subscribeOnce(actor);
+            }
+        }
+
+        if (this.shouldBeEmitted()) {
+            // TODO: use middleware
+            console.log(`[ACTION] ${data.type}`, data.__payload);
+            this.dispatcher.dispatch(data);
+
+            this.emitted = true;
+        }
+        return this.emitted;
+    }
+
+    /**
+     * TODO: use metadata reflection api
+     */
+    protected createAction<ActionType>(actionClass): ActionType {
+        return injector.get<ActionType>(actionClass);
+    }
+}
diff --git a/src/core/Component.ts b/src/core/Component.ts
new file mode 100644
index 0000000..4c914be
--- /dev/null
+++ b/src/core/Component.ts
@@ -0,0 +1,35 @@
+/**
+ * External imports
+ */
+import * as React from 'react';
+import * as _ from 'lodash';
+import * as classname from 'classnames';
+
+/**
+ * Local imports
+ */
+import {injector} from './Injector';
+import {IStateRef, getStateRefs} from '../state';
+
+export class Component<TProps, TState> extends React.Component<TProps, TState> {
+
+    // global state
+    get $(): IStateRef {
+        return getStateRefs();
+    }
+
+    set $(value) {}
+
+    class = (...args: any[]) => {
+        return classname(...args);
+    };
+
+    /**
+     * TODO: use metadata reflection api
+     */
+    createAction<ActionType>(actionClass): ActionType {
+        return injector.get<ActionType>(actionClass);
+    }
+}
+
+export default Component;
diff --git a/src/core/Dispatcher.ts b/src/core/Dispatcher.ts
new file mode 100644
index 0000000..02ccb4b
--- /dev/null
+++ b/src/core/Dispatcher.ts
@@ -0,0 +1,124 @@
+/**
+ * External imports
+ */
+import * as _ from 'lodash';
+import Store = Redux.Store;
+
+/**
+ * Local imports
+ */
+import {injectable} from './Injector';
+import {IState} from '../state';
+import {IDispatcherAction} from './Action';
+
+// TODO: -> Dispatcher<IState> & .store<IState>
+@injectable()
+export class Dispatcher {
+
+    protected acting: boolean = false;
+    protected lastState: IState;
+
+    protected actors: any[] = [];
+    protected singularActors: any[] = [];
+    protected dispatchQueue: IDispatcherAction[] = [];
+    protected store;
+
+    constructor() {
+        this.onStateUpdate = this.onStateUpdate.bind(this);
+        this.subscribeOnce = this.subscribeOnce.bind(this);
+        this.subscribe = this.subscribe.bind(this);
+        this.dispatch = this.dispatch.bind(this);
+    }
+
+    /**
+     * TODO: pass to actors callback to queue dispathing
+     */
+    protected onStateUpdate() {
+        if (!this.acting) {
+            this.acting = true;
+
+            if (this.singularActors.length) {
+                let actor;
+                /**
+                 * Invoke singular actors (to be called once)
+                 */
+                while (actor = this.singularActors.shift()) {
+                    // TODO: actor should not be a pure function, it's inconvenient
+                    actor(this.getState(), this.lastState, this);
+                }
+            }
+
+            /**
+             * Invoke actors
+             */
+            this.actors.forEach((actor) => actor(this.getState(), this.lastState, this));
+
+            /**
+             * After all actors have been processed, it's time
+             * to dispatch next action, that can be created inside actors
+             */
+            this.acting = false;
+            if (this.dispatchQueue.length) {
+                this.dispatch(this.dispatchQueue.shift());
+            }
+        }
+
+        /**
+         * Update last state after all actors invocations
+         */
+        this.lastState = this.getState();
+    }
+
+    attachStore(store) {
+        this.store = store;
+        this.store.subscribe(this.onStateUpdate);
+    };
+
+    subscribeOnce(actor) {
+        this.singularActors.push(actor);
+    };
+
+    /**
+     * @example
+     *   dispather
+     *      .subscribe(updateProgress)
+     *      .until(state => !state.loading)
+     */
+    subscribe(actor): {until: (fn: (state: IState) => boolean) => void} {
+        this.actors.push(actor);
+
+        return {
+            until: (fn: (state: IState) => boolean) => {
+                if (fn(this.getState())) {
+                    this.actors = _.without(this.actors, actor);
+                }
+            }
+        };
+    };
+
+    dispatch(data: IDispatcherAction) {
+        // TODO: think about:
+        // implement queue to be able to
+        // dispatch inside actors
+        // (they may should take dispatcher in params)
+
+        /*
+            new ActionWithActor().emit(data)
+                                      /
+              Reducer.reduce(state, data): IState
+                       ____________________/
+                      /
+               actor(newState, dispatcher) { dispatcher.dispatch(); }
+        */
+
+        if (this.acting) {
+            this.dispatchQueue.push(data);
+        } else {
+            this.store.dispatch(data);
+        }
+    };
+
+    getState() {
+        return this.store.getState();
+    }
+}
diff --git a/src/core/Injector.ts b/src/core/Injector.ts
new file mode 100644
index 0000000..46d7aca
--- /dev/null
+++ b/src/core/Injector.ts
@@ -0,0 +1,51 @@
+/**
+ * External imports
+ */
+import 'reflect-metadata';
+import * as inversify from 'inversify';
+import * as _ from 'lodash';
+import Kernel = inversify.interfaces.Kernel;
+
+/**
+ * Facade decorators
+ */
+export function inject(Provider) {
+    return inversify.inject(Provider);
+}
+
+export function injectable() {
+    return inversify.injectable.apply(null, arguments);
+}
+
+/**
+ * Facade composition for inversify kernel singleton
+ */
+export class Injector {
+
+    constructor() {
+        this.kernel = new inversify.Kernel();
+    }
+
+    protected kernel: Kernel;
+
+    registerProviders(providers: any[]) {
+        _.each(providers, (provider) => {
+            this.kernel.bind<typeof provider>(provider).to(provider);
+        });
+    }
+
+    bindSingleton<I>(provider): void {
+        this.kernel.bind<I>(provider).to(provider).inSingletonScope();
+    }
+
+    bind<I>(provider): void {
+        this.kernel.bind<I>(provider).to(provider);
+    }
+
+    get<I>(provider): I | typeof provider {
+        return this.kernel.get<I | typeof provider>(provider);
+    }
+}
+
+export const injector = new Injector();
+export default injector;
diff --git a/src/core/Reducer.ts b/src/core/Reducer.ts
new file mode 100644
index 0000000..350265f
--- /dev/null
+++ b/src/core/Reducer.ts
@@ -0,0 +1,127 @@
+/**
+ * External imports
+ */
+import * as _ from 'lodash';
+import {combineReducers} from 'redux';
+import {IReducer as IReduxReducer} from '~react-router-redux~redux';
+
+/**
+ * Local imports
+ */
+import {IAction, IDispatcherAction} from './Action';
+import {injectable} from './Injector';
+import {IRef} from './Ref';
+import {initialState} from '../state';
+
+
+export interface IReducer<TState> {
+    getInitialState?(): TState;
+    reduce(state: TState, action: IDispatcherAction): TState;
+    release(path: string);
+}
+
+export type TReducer<TState> = TState | IReducer<TState>;
+
+interface IReduxReducersMapObject {
+    [key: string]: IReduxReducer<any>;
+}
+
+
+@injectable()
+export class Reducer<TState> implements IReducer<TState> {
+
+    protected path: string = '';
+    protected refs: any; // TODO
+
+    protected concatPath(current: string, next: string) {
+        return current ? current + '.' + next : next;
+    }
+
+    protected getChildrenReducers(): IReduxReducersMapObject {
+        return <IReduxReducersMapObject>_.mapValues<TReducer<any>, IReduxReducer<any>>(
+            this.combine(), (reducer: IReducer<any>, key: string) => {
+                return reducer.release(this.concatPath(this.path, key));
+            }
+        );
+    }
+
+    getInitialState(): TState {
+        return <TState>_.cloneDeep(_.get(initialState, this.path));
+    }
+
+    getRelativeRefPath(ref: IRef<any>): string {
+        return ref.path.slice(this.path.length + 1);
+    }
+
+    hasRef(ref: IRef<any> | string): boolean {
+        if (typeof ref === 'string') {
+            return _.has(this.refs, ref);
+        } else {
+            return _.has(this.refs, this.getRelativeRefPath(ref));
+        }
+    }
+
+    release(path: string = this.path): IReduxReducersMapObject | IReduxReducer<TState> {
+        this.path = path;
+
+        const children = this.getChildrenReducers();
+
+        if (_.isEmpty(children)) {
+            if (!_.hasIn(this, 'getInitialState')) {
+                throw new Error(
+                    `Reducer ${this.constructor.name} hasn't childs. Implement initialState method`
+                );
+            }
+
+            const origin = {
+                reduce: this.reduce
+            };
+
+            // TODO:
+            // Set the mutability/immutability functions
+            // setToImmutableStateFunc((mutableState) => Immutable.fromJS(mutableState));
+            // setToMutableStateFunc((immutableState) => immutableState.toJS());
+
+            /**
+             * No needs to call getInitialState in reducer
+             */
+            this.reduce = (state: TState, action: IDispatcherAction): TState => {
+                /**
+                 * No needs to return unchanged state in reducer
+                 */
+                let result = origin.reduce.call(this, state || this.getInitialState(), action) || state || this.getInitialState();
+
+                // TODO: remove prom prod, use middleware
+                console.log('[UPDATE]', this.path, result);
+                return result;
+            };
+
+            return this.reduce;
+
+        } else {
+
+            // is root reducer
+            if (this.path === '') {
+                return children;
+            } else {
+                const childReducer = <IReduxReducer<TState>>combineReducers<TState>(children);
+
+              /**
+               * Wrap childReducer properties
+               * TODO: docs & examples
+               */
+              return (state: TState, action: IDispatcherAction): TState => {
+                  return this.reduce(childReducer(state, action), action);
+              };
+            }
+        }
+    }
+
+    combine(): any { // TODO
+        return null;
+    }
+
+    reduce(state: TState, action: IDispatcherAction): TState  {
+        return state;
+    }
+}
diff --git a/src/core/Ref.ts b/src/core/Ref.ts
new file mode 100644
index 0000000..1638d61
--- /dev/null
+++ b/src/core/Ref.ts
@@ -0,0 +1,52 @@
+/**
+ * External imports
+ */
+import * as _ from 'lodash';
+
+/**
+ * Local imports
+ */
+import {injectable, inject} from './Injector';
+import {Dispatcher} from './Dispatcher';
+
+/**
+ * Interfaces
+ */
+export interface IRef<TType> {
+    key: string;
+    val: TType;
+    path: string;
+}
+
+/**
+ * Reference to state value
+ */
+@injectable()
+export class Ref<TType> implements IRef<TType> {
+
+    protected _path: string;
+
+    constructor(
+        @inject(Dispatcher) protected dispatcher: Dispatcher
+    ) {}
+
+    get val(): TType {
+        return <TType>_.get(this.dispatcher.getState(), this.path);
+    }
+
+    get key(): string {
+        return _.last(this._path.split('.'));
+    }
+
+    get path(): string {
+        return this._path;
+    }
+
+    link(path: string): Ref<TType> {
+        if (this._path) {
+            throw `State reference can be linked only once (${this._path})`;
+        }
+        this._path = path;
+        return this;
+    }
+}
diff --git a/src/core/Validator.ts b/src/core/Validator.ts
new file mode 100644
index 0000000..1c759ca
--- /dev/null
+++ b/src/core/Validator.ts
@@ -0,0 +1,24 @@
+/**
+ * External imports
+ */
+import * as _ from 'lodash';
+
+/**
+ * Local imports
+ */
+import {injectable} from './Injector';
+
+export interface IValidator<TValidationRules, TValidationResult> {
+    validate(value: any, rules?: TValidationRules): TValidationResult;
+    check(value: any, rules?: TValidationRules): boolean;
+}
+
+@injectable()
+export abstract class Validator<TValidationRules, TValidationResult> implements IValidator<TValidationRules, TValidationResult> {
+
+    check(value: any, rules?: TValidationRules) {
+        return _.every(<any>this.validate(value, rules), result => !!result);
+    }
+
+    abstract validate(value: any, rules?: TValidationRules): TValidationResult;
+}
\ No newline at end of file
diff --git a/src/index.tsx b/src/index.tsx
index 582e0c8..035a9a8 100644
--- a/src/index.tsx
+++ b/src/index.tsx
@@ -1,20 +1,30 @@
-import * as React from "react";
-import { Router, browserHistory } from "react-router";
-import { render } from "react-dom";
-import { Provider } from "react-redux";
-import { syncHistoryWithStore } from "react-router-redux";
-import configureStore from "./store";
-import routes from "./routes";
+/**
+ * External imports
+ */
+import * as React from 'react';
+import { Router, browserHistory } from 'react-router';
+import { render } from 'react-dom';
+import { Provider } from 'react-redux';
+import { syncHistoryWithStore } from 'react-router-redux';
+
+/**
+ * Local imports
+ */
+import './providers';
+import configureStore from './store';
+import routes from './routes';

 /* tslint:disable:no-var-requires */
-require("./styles/global.scss");
+require('./styles/global.scss');
 /* tslint:enable:no-var-requires */

 /* tslint:disable:no-string-literal */
-const preloadedState = global["window"] && global["window"]["__PRELOADED__"];
+const preloadedState = global['window'] && global['window']['__PRELOADED__'];
+/* tslint:enable:no-string-literal */

-if (module["hot"]) {
-  module["hot"].accept();
+/* tslint:disable:no-string-literal */
+if (module['hot']) {
+  module['hot'].accept();
 }
 /* tslint:enable:no-string-literal */

@@ -25,5 +35,5 @@ render(
   <Provider store={store}>
     <Router history={history} routes={routes} />
   </Provider>,
-  document.getElementById("root")
+  document.getElementById('root')
 );
diff --git a/src/providers.ts b/src/providers.ts
new file mode 100644
index 0000000..d497b5a
--- /dev/null
+++ b/src/providers.ts
@@ -0,0 +1,76 @@
+/**
+ * External imports
+ */
+import {createStore} from 'redux';
+
+/**
+ * Import injector before providers
+ */
+import {injector} from './core/Injector';
+
+/**
+ * Import providers
+ */
+import {AppReducer} from './reducers/App';
+import {ToggleCheckbox} from './actions/ToggleCheckbox';
+import {ClientFormReducer} from './reducers/ClientForm';
+import {DateValidator} from './validators/DateValidator';
+import {Dispatcher} from './core/Dispatcher';
+import {EmailValidator} from './validators/EmailValidator';
+import {ChangeInputValue} from './actions/ChangeInputValue';
+import {OnlyRussianCharsValidator} from './validators/OnlyRussianCharsValidator';
+import {PassportValidator} from './validators/PassportValidator';
+import {PatternValidator} from './validators/PatternValidator';
+import {Ref} from './core/Ref';
+import {SaveClient, ShowClientSaved} from './actions/SaveClient';
+import {SelectOption} from './actions/SelectOption';
+import {TextLengthValidator} from './validators/TextLengthValidator';
+import {Validator} from './core/Validator';
+import {NotificationsReducer} from './reducers/NotificationsReducer';
+import {ShowNotification, HideNotificationByTimeOut} from './actions/ShowNotification';
+
+
+/**
+ * Singletons
+ */
+injector.bindSingleton<AppReducer>(AppReducer);
+injector.bindSingleton<Dispatcher>(Dispatcher);
+
+injector.registerProviders([
+    /**
+     * Core
+     */
+    Ref,
+    Validator,
+
+    /**
+     * Reducers
+     */
+    ClientFormReducer,
+    NotificationsReducer,
+
+    /**
+     * Actions
+     */
+    ChangeInputValue,
+    ToggleCheckbox,
+    SelectOption,
+    SaveClient,
+    ShowClientSaved,
+    ShowNotification,
+    HideNotificationByTimeOut,
+
+    /**
+     * Actors // TODO
+     */
+
+    /**
+     * Validators
+     */
+    TextLengthValidator,
+    OnlyRussianCharsValidator,
+    PatternValidator,
+    PassportValidator,
+    DateValidator,
+    EmailValidator
+]);
diff --git a/src/reducers/App.ts b/src/reducers/App.ts
new file mode 100644
index 0000000..e011879
--- /dev/null
+++ b/src/reducers/App.ts
@@ -0,0 +1,34 @@
+/**
+ * Local imports
+ */
+import {Reducer, IReducer} from '../core/Reducer';
+import {inject} from '../core/Injector';
+import {ClientFormReducer} from './ClientForm';
+import ReducersMapObject = Redux.ReducersMapObject;
+import {IClientForm, IState} from '../state';
+import {NotificationsReducer} from './NotificationsReducer';
+import {INotification} from '../actions/ShowNotification';
+
+/**
+ * Root application reducer
+ */
+export class AppReducer extends Reducer<IState> {
+
+    constructor(
+        @inject(ClientFormReducer) protected clientFormReducer: IReducer<IClientForm>,
+        @inject(NotificationsReducer) protected notificationsReducer: IReducer<INotification[]>
+    ) {
+        super();
+    }
+
+    combine() {
+        return {
+            notifications: this.notificationsReducer,
+            clientForm: this.clientFormReducer
+        };
+    }
+
+    reduce(state: IState, action): IState {
+        return state;
+    }
+}
diff --git a/src/reducers/ClientForm.ts b/src/reducers/ClientForm.ts
new file mode 100644
index 0000000..7360a4d
--- /dev/null
+++ b/src/reducers/ClientForm.ts
@@ -0,0 +1,131 @@
+/**
+ * External imports
+ */
+import * as _ from 'lodash';
+
+/**
+ * Local imports
+ */
+import {DateValidator} from '../validators/DateValidator';
+import {EmailValidator} from '../validators/EmailValidator';
+import {initialState, IClientForm, IClientFormRef, getStateRefs} from '../state';
+import {injectable, inject} from '../core/Injector';
+import {ChangeInputValue, IChangeInputValuePayload} from '../actions/ChangeInputValue';
+import {OnlyRussianCharsValidator} from '../validators/OnlyRussianCharsValidator';
+import {PassportValidator} from '../validators/PassportValidator';
+import {Reducer} from '../core/Reducer';
+import {ToggleCheckbox} from '../actions/ToggleCheckbox';
+import {SelectOption} from '../actions/SelectOption';
+import {SaveClient, ShowClientSaved} from '../actions/SaveClient';
+
+@injectable()
+export class ClientFormReducer extends Reducer<IClientForm> {
+
+    static key = 'clientForm';
+
+    protected get refs(): IClientFormRef {
+        return getStateRefs().clientForm;
+    }
+
+    constructor(
+        @inject(OnlyRussianCharsValidator) protected onlyRussianCharsValidator: OnlyRussianCharsValidator,
+        @inject(PassportValidator) protected passwordValidator: PassportValidator,
+        @inject(EmailValidator) protected emailValidator: EmailValidator,
+        @inject(DateValidator) protected dateValidator: DateValidator
+    ) {
+        super();
+    }
+
+    reduce(state, action) {
+        switch (action.class) {
+            case ChangeInputValue:
+            case ToggleCheckbox:
+            case SelectOption:
+                const payload = ChangeInputValue.getPayload<IChangeInputValuePayload>(action);
+                if (this.hasRef(payload.ref)) {
+                    return this.reduceInputValue(state, payload);
+                }
+                return state;
+
+            case SaveClient:
+                return this.setLoading(state, true);
+
+            case ShowClientSaved:
+                return this.getInitialState();
+
+            default:
+                return state;
+        }
+    }
+
+    setLoading(state: IClientForm, isLoading: boolean) {
+        // TODO: use immutable
+        return _.assign({}, state, {
+            loading: isLoading
+        });
+    }
+
+    protected validateFormValue(state, payload) {
+        switch (payload.ref) {
+            /**
+             * Use filtering (return validation result)
+             */
+            case this.refs.data.name:
+            case this.refs.data.surname:
+            case this.refs.data.middlename: {
+                return this.onlyRussianCharsValidator.check(payload.value, {
+                    minLength: 0,
+                    maxLength: 127
+                });
+            }
+
+            case this.refs.data.passport: {
+                return this.passwordValidator.check(payload.value, {
+                    length: payload.selection[1]
+                });
+            }
+
+            case this.refs.data.birthday: {
+                return this.dateValidator.check(payload.value, {
+                    length: payload.selection[1]
+                });
+            }
+
+            /**
+             * Only update errors (do not return values)
+             */
+            case this.refs.data.email:
+                state.errors.email = !payload.value || this.emailValidator.check(payload.value) ?
+                    '' : '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü—Ä–∏–º–µ—Ä: user@domain.zone';
+
+            /**
+             * Reset car model on car brand change
+             */
+            case this.refs.data.car.brand:
+                state.data.car.model = ''; // reset car model
+
+            /**
+             * Cleanup car data when car didn't exist
+             */
+            case this.refs.data.car.exists:
+                if (payload.value === false) {
+                    state.data.car = _.clone(initialState.clientForm.data.car);
+                }
+
+            /**
+             * Permit state mutation by default
+             */
+            default:
+                return true;
+        }
+    }
+
+    // TODO: typings
+    protected reduceInputValue(state, payload) {
+        if (this.validateFormValue(state, payload)) {
+            // TODO: use immutable
+            return _.set(_.cloneDeep(state), this.getRelativeRefPath(payload.ref), payload.value);
+        }
+    }
+}
+
diff --git a/src/reducers/NotificationsReducer.ts b/src/reducers/NotificationsReducer.ts
new file mode 100644
index 0000000..0f3ac88
--- /dev/null
+++ b/src/reducers/NotificationsReducer.ts
@@ -0,0 +1,27 @@
+/**
+ * External imports
+ */
+import * as _ from 'lodash';
+
+/**
+ * Local imports
+ */
+import {Reducer} from '../core/Reducer';
+import {Action} from '../core/Action';
+import {INotification, ShowNotification, HideNotificationByTimeOut} from '../actions/ShowNotification';
+
+export class NotificationsReducer extends Reducer<INotification> {
+
+    reduce(state, action) {
+        switch(action.class) {
+            case ShowNotification:
+                return state.concat([ShowNotification.getPayload(action)]);
+
+            case HideNotificationByTimeOut:
+                return _.filter(state, (notification: INotification) => {
+                    return notification.id !== HideNotificationByTimeOut.getPayload(action);
+                });
+        }
+        return state;
+    }
+}
diff --git a/src/reducers/definition.ts b/src/reducers/definition.ts
deleted file mode 100644
index cd6502b..0000000
--- a/src/reducers/definition.ts
+++ /dev/null
@@ -1,42 +0,0 @@
-import { handleActions, Action } from "redux-actions";
-import { DEFINITION_START, DEFINITION_DONE, DEFINITION_ERROR } from "../actions/definition";
-import { IEntry } from "../api/Entry";
-
-interface IDefinitionState {
-  entries?: IEntry[];
-  error?: Error;
-  isLoading?: boolean;
-}
-
-const initialState: IDefinitionState = {
-  entries: [],
-  error: null,
-  isLoading: false,
-};
-
-/* tslint:disable:object-literal-sort-keys */
-export const definitionReducer = handleActions({
-
-  [DEFINITION_START]: (state: IDefinitionState, action: Action<any>): IDefinitionState =>
-    Object.assign({}, state, {
-      error: null,
-      isLoading: true,
-    } as IDefinitionState),
-
-  [DEFINITION_DONE]: (state: IDefinitionState, action: Action<any>): IDefinitionState =>
-    Object.assign({}, state, {
-      entries: action.payload,
-      error: null,
-      isLoading: false,
-    } as IDefinitionState),
-
-  [DEFINITION_ERROR]: (state: IDefinitionState, action: Action<any>): IDefinitionState =>
-    Object.assign({}, state, {
-      entries: [],
-      error: action.payload,
-      isLoading: false,
-    } as IDefinitionState),
-
-}, initialState);
-
-export default definitionReducer;
diff --git a/src/reducers/index.ts b/src/reducers/index.ts
index 42a3f7e..0cbb2f0 100644
--- a/src/reducers/index.ts
+++ b/src/reducers/index.ts
@@ -1,12 +1,2 @@
-import { combineReducers } from "redux";
-import { routerReducer } from "react-router-redux";
-import { definitionReducer } from "./definition";
-import { searchReducer } from "./search";
-
-const rootReducer = combineReducers({
-  definition: definitionReducer,
-  routing: routerReducer,
-  search: searchReducer,
-});
-
-export default rootReducer;
+import App from '../containers/App/App';
+export default App;
diff --git a/src/reducers/search.ts b/src/reducers/search.ts
deleted file mode 100644
index f17a517..0000000
--- a/src/reducers/search.ts
+++ /dev/null
@@ -1,45 +0,0 @@
-import { handleActions, Action } from "redux-actions";
-import { SEARCH_START, SEARCH_DONE, SEARCH_ERROR } from "../actions/search";
-import { IEntry } from "../api/Entry";
-
-interface ISearchState {
-  entries?: IEntry[];
-  error?: Error;
-  isLoading?: boolean;
-  prefix?: string;
-}
-
-const initialState: ISearchState = {
-  entries: [],
-  error: null,
-  isLoading: false,
-  prefix: null,
-};
-
-/* tslint:disable:object-literal-sort-keys */
-export const searchReducer = handleActions({
-
-  [SEARCH_START]: (state: ISearchState, action: Action<any>): ISearchState =>
-    Object.assign({}, state, {
-      error: null,
-      isLoading: true,
-      prefix: action.payload,
-    } as ISearchState),
-
-  [SEARCH_DONE]: (state: ISearchState, action: Action<any>): ISearchState =>
-    Object.assign({}, state, {
-      entries: action.payload,
-      error: null,
-      isLoading: false,
-    } as ISearchState),
-
-  [SEARCH_ERROR]: (state: ISearchState, action: Action<any>): ISearchState =>
-    Object.assign({}, state, {
-      entries: [],
-      error: action.payload,
-      isLoading: false,
-    } as ISearchState),
-
-}, initialState);
-
-export default searchReducer;
diff --git a/src/routes.tsx b/src/routes.tsx
index cb57187..dc1d8fe 100644
--- a/src/routes.tsx
+++ b/src/routes.tsx
@@ -1,13 +1,10 @@
-import * as React from "react";
-import { Route, IndexRoute } from "react-router";
-import App from "./containers/App";
-import Definition from "./containers/Definition";
-import Search from "./containers/Search";
+import * as React from 'react';
+import { Route, IndexRoute } from 'react-router';
+import App from './containers/App/App';
+import {ClientForm} from './containers/ClientForm/ClientForm';

 export default (
-  <Route path="/" component={App} >
-    <IndexRoute component={Search}/>
-    <Route path="search(/:prefix)" component={Search} />
-    <Route path="define/:id" component={Definition} />
+  <Route path='/' component={App} >
+    <IndexRoute component={ClientForm}/>
   </Route>
 );
diff --git a/src/sagas/definition.ts b/src/sagas/definition.ts
deleted file mode 100644
index ee3bbd1..0000000
--- a/src/sagas/definition.ts
+++ /dev/null
@@ -1,19 +0,0 @@
-import { takeEvery } from "redux-saga";
-import { call, CallEffect, put, PutEffect } from "redux-saga/effects";
-import { define } from "../api/DictionaryAPI";
-import { DEFINITION_START, definitionDone, definitionError } from "../actions/definition";
-
-export function* definitionTask(action): IterableIterator<CallEffect | PutEffect<any>> {
-  const id: string = action.payload;
-
-  try {
-    const entries = yield call(define, id);
-    yield put(definitionDone(entries));
-  } catch (error) {
-    yield put(definitionError(error));
-  }
-}
-
-export default function* definitionSaga() {
-  yield* takeEvery(DEFINITION_START, definitionTask);
-}
diff --git a/src/sagas/index.ts b/src/sagas/index.ts
deleted file mode 100644
index 1eea4de..0000000
--- a/src/sagas/index.ts
+++ /dev/null
@@ -1,9 +0,0 @@
-import definitionSaga from "./definition";
-import searchSaga from "./search";
-
-export default function* rootSaga(): IterableIterator<any> {
-  yield [
-    definitionSaga(),
-    searchSaga(),
-  ];
-}
diff --git a/src/sagas/search.ts b/src/sagas/search.ts
deleted file mode 100644
index 306e52c..0000000
--- a/src/sagas/search.ts
+++ /dev/null
@@ -1,25 +0,0 @@
-import { takeLatest, delay } from "redux-saga";
-import { call, CallEffect, put, PutEffect } from "redux-saga/effects";
-import { search } from "../api/DictionaryAPI";
-import { SEARCH_START, searchDone, searchError } from "../actions/search";
-
-export function* searchTask(action): IterableIterator<CallEffect | PutEffect<any>> {
-  const prefix: string = action.payload;
-
-  try {
-    let results = [];
-
-    if (prefix && prefix.trim().length) {
-      yield call(delay, 200);
-      results = yield call(search, prefix);
-    }
-
-    yield put(searchDone(results));
-  } catch (error) {
-    yield put(searchError(error));
-  }
-}
-
-export default function* searchSaga() {
-  yield* takeLatest(SEARCH_START, searchTask);
-}
diff --git a/src/server/compileAssets.ts b/src/server/compileAssets.ts
index c7cdaee..6ee7833 100644
--- a/src/server/compileAssets.ts
+++ b/src/server/compileAssets.ts
@@ -6,7 +6,8 @@ export default function compileAssets(): Object {
     return {
       main: {
         js: "/static/main.js",
-      },
+        css: "/static/main.css"
+      }
     };
   }

diff --git a/src/server/index.ts b/src/server/index.ts
index 112af72..5cbe705 100644
--- a/src/server/index.ts
+++ b/src/server/index.ts
@@ -1,19 +1,32 @@
-import * as express from "express";
-import proxy = require("http-proxy-middleware");
-import webpack = require("webpack");
-import webpackDevMiddleware = require("webpack-dev-middleware");
-import webpackHotMiddleware = require("webpack-hot-middleware");
-import { browserHistory, match } from "react-router";
-import routes from "../routes";
-import handleRoute from "./handleRoute";
+/**
+ * External imports
+ */
+import * as express from 'express';
+import proxy = require('http-proxy-middleware');
+import webpack = require('webpack');
+import webpackDevMiddleware = require('webpack-dev-middleware');
+import webpackHotMiddleware = require('webpack-hot-middleware');
+import { browserHistory, match } from 'react-router';
+
+/**
+ * Local imports
+ */
+import '../providers';
+
+import handleRoute from './handleRoute';
+import routes from '../routes';

 const port = process.env.PORT || 3000;
 const app = express();

-if (process.env.NODE_ENV === "development") {
+/**
+ * Webpack
+ */
+if (process.env.NODE_ENV === 'development') {
   /* tslint:disable:no-var-requires */
-  const config = require("../../webpack.config");
+  const config = require('../../webpack.config');
   /* tslint:enable:no-var-requires */
+
   const compiler = webpack(config);

   app.use(webpackHotMiddleware(compiler));
@@ -23,18 +36,17 @@ if (process.env.NODE_ENV === "development") {
   }));
 }

-app.use("/api/", proxy({
-  changeOrigin: true,
-  pathRewrite: { "^/api/": "/" },
-  // FIXME: Move to configuration file.
-  target: "http://dicionario-aberto.net",
-}));
-
-app.use(express.static("dist", {
-  extensions: ["css", "js"],
-  index: false,
+/**
+ * Serve static
+ */
+app.use(express.static('dist', {
+  extensions: ['css', 'js'],
+  index: false
 }));

+/**
+ * Server rendering
+ */
 app.use((req, res, next) => {
   match(<any> {
     history: browserHistory,
@@ -43,6 +55,9 @@ app.use((req, res, next) => {
   }, handleRoute(req, res, next));
 });

+/**
+ * Initialization
+ */
 app.listen(port, (error) => {
   if (error) {
     console.error(error);
diff --git a/src/server/render.tsx b/src/server/render.tsx
index 2583f6c..1888bc7 100644
--- a/src/server/render.tsx
+++ b/src/server/render.tsx
@@ -1,48 +1,38 @@
-import * as React from "react";
-import "react-dom";
-import { renderToString } from "react-dom/server";
-import { Provider } from "react-redux";
-import { RouterContext } from "react-router";
-import { fork, join } from "redux-saga/effects";
-import configureStore from "../store";
-import compileAssets from "./compileAssets";
-import Document from "../containers/Document";
+/**
+ * External imports
+ */
+import * as React from 'react';
+import 'react-dom';
+import { renderToString } from 'react-dom/server';
+import { Provider } from 'react-redux';
+import { RouterContext } from 'react-router';

 /**
- * Wait for all preload sagas to complete.
- * @param  {Array} sagas Preload sagas.
+ * Local imports
  */
-function waitAll(sagas) {
-  return function* () {
-    const tasks = yield sagas.map(([saga, ...params]) => fork(saga, ...params));
-    yield tasks.map(join);
-  };
-}
+import configureStore from '../store';
+import compileAssets from './compileAssets';
+import Document from '../containers/Document/Document';

 function render(req, res, renderProps) {
-  const { components, params } = renderProps;
-  const store = configureStore();
+    const store = configureStore();

-  const preloaders = components
-    .filter(component => component && component.preload)
-    .map(component => component.preload(params))
-    .reduce((result, preloader) => result.concat(preloader), []);
+    // const { components, params } = renderProps;
+    // TODO
+    // const preloaders = components
+    //     .filter(component => component && component.preload)
+    //     .map(component => component.preload(params))
+    //     .reduce((result, preloader) => result.concat(preloader), []);

-  store.runSaga(waitAll(preloaders)).done
-    .then(() => {
-      const app = (
+    const app = (
         <Provider store={store}>
-          <RouterContext {...renderProps} />
+            <RouterContext {...renderProps} />
         </Provider>
-      );
+    );

-      res.send("<!DOCTYPE HTML>\n" + renderToString(
+    res.send('<!DOCTYPE HTML>\n' + renderToString(
         <Document app={app} assets={compileAssets()} server store={store} />
-      ));
-    })
-    .catch((sagaError) => {
-      res.status(500).send(sagaError.message);
-    });
+    ));
 }

 export default render;
diff --git a/src/state.yml b/src/state.yml
new file mode 100644
index 0000000..9751bc3
--- /dev/null
+++ b/src/state.yml
@@ -0,0 +1,18 @@
+clientForm:
+    loading: false
+    message: ''
+    errors:
+        email: ''
+    data:
+        surname: ''
+        name: ''
+        middlename: ''
+        email: ''
+        birthday: 'MM.DD.YYYY'
+        passport: '____ ______'
+        car:
+            exists: false
+            brand: ''
+            model: ''
+
+notifications: []
diff --git a/src/store.ts b/src/store.ts
index df2ea68..72c77fb 100644
--- a/src/store.ts
+++ b/src/store.ts
@@ -1,46 +1,61 @@
-import { createStore, applyMiddleware, compose } from "redux";
-import createSagaMiddleware, { END } from "redux-saga";
-import { browserHistory } from "react-router";
-import { routerMiddleware } from "react-router-redux";
-import rootReducer from "./reducers";
-import sagas from "./sagas";
+/**
+ * External imports
+ */
+import {browserHistory} from 'react-router';
+import {createStore, applyMiddleware, compose, combineReducers} from 'redux';
+import {routerMiddleware} from 'react-router-redux';
+
+/**
+ * Local imports
+ */
+import {AppReducer} from './reducers/App';
+import {Dispatcher} from './core/Dispatcher';
+import {injector} from './core/Injector';
+import {routerReducer} from 'react-router-redux';

 /* tslint:disable:no-string-literal */
-const devTools = global["devToolsExtension"] || (() => noop => noop);
+const devTools = global['devToolsExtension'] || (() => noop => noop);
 /* tslint:enable:no-string-literal */

-export default function configureStore(initialState: Object = {}) {
-  const sagaMiddleware = createSagaMiddleware();
-
-  const middlewares = [
-    routerMiddleware(browserHistory),
-    sagaMiddleware,
-  ];
-
-  const store = createStore(
-    rootReducer,
-    initialState,
-    compose(
-      applyMiddleware(...middlewares),
-      devTools()
-    )
-  ) as any;
-
-  sagaMiddleware.run(sagas);
-
-  store.runSaga = sagaMiddleware.run;
-  store.close = () => store.dispatch(END);
-
-  // Hot reload reducers:
-  // https://github.com/reactjs/react-redux/releases/tag/v2.0.0
-  /* tslint:disable:no-string-literal */
-  if (process.env.NODE_ENV === "development" && module["hot"]) {
-    module["hot"].accept("./reducers", () => {
-      const nextRootReducer = require("./reducers").default;
-      store.replaceReducer(nextRootReducer);
-    });
-  }
-  /* tslint:enable:no-string-literal */
-
-  return store;
+function getReducers() {
+    return injector.get(AppReducer).release();
+}
+
+export default function configureStore(initialState:Object = {}) {
+
+    const reducers = getReducers();
+    const dispatcher:Dispatcher = injector.get(Dispatcher);
+
+    const middlewares = [
+        routerMiddleware(browserHistory),
+    ];
+
+    const store = createStore(
+        combineReducers(Object.assign(reducers, {
+            routing: routerReducer
+        })),
+        initialState,
+        compose(
+            applyMiddleware(...middlewares),
+            devTools()
+        )
+    ) as any;
+
+    dispatcher.attachStore(store);
+
+    /* tslint:disable:no-string-literal */
+    if (process.env.NODE_ENV === 'development' && module['hot']) {
+        module['hot'].accept('./reducers', () => {
+            const AppReducer = require('./reducers/App').AppReducer;
+            injector.bind(AppReducer);
+            const reducers = getReducers();
+
+            store.replaceReducer(combineReducers(Object.assign(reducers, {
+                routing: routerReducer
+            })));
+        });
+    }
+    /* tslint:enable:no-string-literal */
+
+    return store;
 }
diff --git a/src/styles/colors.scss.d.ts b/src/styles/colors.scss.d.ts
new file mode 100644
index 0000000..32a2eb8
--- /dev/null
+++ b/src/styles/colors.scss.d.ts
@@ -0,0 +1,6 @@
+export const body: string;
+export const meta: string;
+export const panel: string;
+export const field: string;
+export const action: string;
+export const loader: string;
\ No newline at end of file
diff --git a/src/styles/effects.scss b/src/styles/effects.scss
index 07d677a..57add00 100644
--- a/src/styles/effects.scss
+++ b/src/styles/effects.scss
@@ -9,13 +9,13 @@

 .outline {
   &:focus {
-    border: 2px solid #a50000;
+    border: 1px solid #2f6fad;
     outline: 0;
   }
 }

 .rounded {
-  border-radius: 1.5rem;
+  border-radius: 0.5rem;
 }

 .shadowed {
diff --git a/src/styles/effects.scss.d.ts b/src/styles/effects.scss.d.ts
new file mode 100644
index 0000000..9fee0b7
--- /dev/null
+++ b/src/styles/effects.scss.d.ts
@@ -0,0 +1,6 @@
+export const bordered: string;
+export const embossed: string;
+export const outline: string;
+export const rounded: string;
+export const shadowed: string;
+export const underlined: string;
\ No newline at end of file
diff --git a/src/styles/global.scss b/src/styles/global.scss
index 9cfce74..24a3c79 100644
--- a/src/styles/global.scss
+++ b/src/styles/global.scss
@@ -1,5 +1,5 @@
 @import "~ress";

-body {
+html {
   background-color: #eee;
 }
diff --git a/src/styles/global.scss.d.ts b/src/styles/global.scss.d.ts
new file mode 100644
index 0000000..e69de29
diff --git a/src/styles/typography.scss b/src/styles/typography.scss
index 538c90c..4b3f7ac 100644
--- a/src/styles/typography.scss
+++ b/src/styles/typography.scss
@@ -24,10 +24,6 @@
   font-size: 1.4rem;
 }

-.undecorated {
-  text-decoration: none;
-}
-
 .centered {
   text-align: center;
 }
diff --git a/src/styles/typography.scss.d.ts b/src/styles/typography.scss.d.ts
new file mode 100644
index 0000000..3e15f01
--- /dev/null
+++ b/src/styles/typography.scss.d.ts
@@ -0,0 +1,10 @@
+export const base: string;
+export const normal: string;
+export const bold: string;
+export const italic: string;
+export const regular: string;
+export const large: string;
+export const centered: string;
+export const title: string;
+export const text: string;
+export const meta: string;
\ No newline at end of file
diff --git a/src/validators/DateValidator.ts b/src/validators/DateValidator.ts
new file mode 100644
index 0000000..71013fd
--- /dev/null
+++ b/src/validators/DateValidator.ts
@@ -0,0 +1,74 @@
+/**
+ * External imports
+ */
+import * as _ from 'lodash';
+import * as moment from 'moment';
+import {Validator} from '../core/Validator';
+
+/**
+ * Local imports
+ */
+
+interface IRules {
+    format?: string;
+
+    /**
+     * If incoming value is not complete (01.12.2)
+     */
+    partial?: boolean;
+
+    /**
+     * If incoming value contains mask (01.12.2YYY)
+     */
+    length?: number;
+}
+
+interface IResults {
+    format: boolean;
+}
+
+export class DateValidator extends Validator<IRules, IResults> {
+
+    defaultRules = {
+        format: 'DD.MM.YYYY',
+        partial: false
+    };
+
+    /**
+     * concat value as head and with the rest of example date
+     * @example for length 7
+     *
+     *  '31.1(M.YYYY)' + (01.1)2.1970 -> 31.13.1970
+     *            \_________/
+     *                 \_ should be cutted
+     */
+    template(val: string, rules): string {
+        /**
+         * Use Dec in template to to avoid date invalidation in case
+         * of days come before month and its value is '31' and first
+         * decimal of month is '1' (+1 is bad for days > 28)
+         */
+        const template: string = moment(0).add('month', -1).add('year', 1)
+            .format(rules.format);
+
+        /**
+         * If length wasn't passed, use value length
+         */
+        const length: number = _.isNumber(rules.length) && rules.length || val.length;
+
+        return val.slice(0, rules.length) + template.slice(rules.length);
+    }
+
+    validate(value: string, rules: IRules = this.defaultRules) {
+        _.defaults(rules, this.defaultRules);
+
+        if (rules.length || rules.partial) {
+            value = this.template(value, rules);
+        }
+
+        return {
+            format: moment(value, rules.format, true).isValid()
+        };
+    }
+
+}
diff --git a/src/validators/EmailValidator.ts b/src/validators/EmailValidator.ts
new file mode 100644
index 0000000..edeb6a1
--- /dev/null
+++ b/src/validators/EmailValidator.ts
@@ -0,0 +1,17 @@
+/**
+ * External imports
+ */
+import * as _ from 'lodash';
+
+/**
+ * Local imports
+ */
+import {PatternValidator} from './PatternValidator';
+
+export class EmailValidator extends PatternValidator {
+
+    defaultRules = {
+        pattern: /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i
+    };
+
+}
\ No newline at end of file
diff --git a/src/validators/OnlyRussianCharsValidator.ts b/src/validators/OnlyRussianCharsValidator.ts
new file mode 100644
index 0000000..45b9dc7
--- /dev/null
+++ b/src/validators/OnlyRussianCharsValidator.ts
@@ -0,0 +1,26 @@
+/**
+ * Local imports
+ */
+import {injectable, inject} from '../core/Injector';
+import {Validator} from '../core/Validator';
+import {ITextLengthValidatorResult, TextLengthValidator, ITextLengthValidatorRules} from './TextLengthValidator';
+
+export interface IOnlyRussianCharsValidatorResults extends ITextLengthValidatorResult {
+    onlyRus: boolean;
+}
+
+@injectable()
+export class OnlyRussianCharsValidator extends Validator<ITextLengthValidatorRules, IOnlyRussianCharsValidatorResults> {
+
+    constructor(
+        @inject(TextLengthValidator) protected textLengthValidator
+    ) {
+        super();
+    }
+
+    validate(value: string, rules?: ITextLengthValidatorRules) {
+        const result = this.textLengthValidator.validate(value, rules);
+        result.onlyRus = !/[^–∞-—è]+/i.test(value);
+        return result;
+    }
+}
diff --git a/src/validators/PassportValidator.ts b/src/validators/PassportValidator.ts
new file mode 100644
index 0000000..7365ca1
--- /dev/null
+++ b/src/validators/PassportValidator.ts
@@ -0,0 +1,18 @@
+/**
+ * External imports
+ */
+import * as _ from 'lodash';
+
+/**
+ * Local imports
+ */
+import {PatternValidator} from './PatternValidator';
+
+export class PassportValidator extends PatternValidator {
+
+    defaultRules = {
+        pattern: /\d{4}\s\d{6}/,
+        template: '0000 000000'
+    };
+
+}
\ No newline at end of file
diff --git a/src/validators/PatternValidator.ts b/src/validators/PatternValidator.ts
new file mode 100644
index 0000000..b65af34
--- /dev/null
+++ b/src/validators/PatternValidator.ts
@@ -0,0 +1,69 @@
+/**
+ * External imports
+ */
+import * as _ from 'lodash';
+
+/**
+ * Local imports
+ */
+import {Validator} from '../core/Validator';
+
+/**
+ * Interfaces
+ */
+export interface IPatternValidatorRules {
+    pattern?: RegExp;
+    template?: string;
+    partial?: boolean;
+    length?: number;
+}
+
+/**
+ * That rules must be declared in inherited classes
+ */
+export interface IPatternValidatorDefaltRules {
+    pattern: RegExp;
+}
+
+export interface IResults {
+    valid: boolean;
+}
+
+/**
+ * Validator that accepts rules to validate different types of text
+ */
+export class PatternValidator extends Validator<IPatternValidatorRules, IResults> {
+
+    defaultRules: IPatternValidatorDefaltRules = {
+        pattern: /.*/
+    };
+
+    template(val: string, rules: IPatternValidatorRules): string {
+        if (!rules.template) {
+            // TODO: add env check
+            throw new Error(`${this.constructor.name} needs template to apply partial validation`);
+        }
+        /**
+         * If length wasn't passed, use value length
+         */
+        const length: number = _.isNumber(rules.length) && rules.length || val.length;
+        return val.slice(0, length) + rules.template.slice(length);
+    }
+
+    validate(value: string, rules: IPatternValidatorRules = this.defaultRules) {
+        _.defaults(rules, this.defaultRules);
+
+        if (!rules.pattern) {
+            return {valid: false};
+        }
+
+        if (rules.length || rules.partial) {
+            value = this.template(value, rules);
+        }
+
+        return {
+            valid: rules.pattern.test(value)
+        };
+    }
+
+}
diff --git a/src/validators/TextLengthValidator.ts b/src/validators/TextLengthValidator.ts
new file mode 100644
index 0000000..2834d24
--- /dev/null
+++ b/src/validators/TextLengthValidator.ts
@@ -0,0 +1,42 @@
+/**
+ * Local imports
+ */
+import {injectable} from '../core/Injector';
+import {Validator} from '../core/Validator';
+
+/**
+ * Interfaces
+ */
+export interface ITextLengthValidatorRules {
+    minLength?: number;
+    maxLength?: number;
+}
+
+export interface ITextLengthValidatorResult {
+    minLength: boolean;
+    maxLength: boolean;
+}
+
+/**
+ * Validator, that checks if given text length is out of bounds
+ */
+@injectable()
+export class TextLengthValidator extends Validator<ITextLengthValidatorRules, ITextLengthValidatorResult> {
+
+    static validateMinLength(value, min) {
+        return (min || -Infinity) <= value.length;
+    }
+
+    static validateMaxLength(value, max) {
+        return value.length <= (max || Infinity);
+    }
+
+    validate(value: string, rules?: ITextLengthValidatorRules) {
+        return {
+            minLength: TextLengthValidator.validateMinLength(value, rules.minLength),
+            maxLength: TextLengthValidator.validateMaxLength(value, rules.maxLength)
+        };
+    }
+}
+
+
diff --git a/src/vars.tsx b/src/vars.tsx
new file mode 100644
index 0000000..29ad8e9
--- /dev/null
+++ b/src/vars.tsx
@@ -0,0 +1,6 @@
+export const ARROW_KEYS: number[] = [37, 38, 39, 40];
+
+export enum NotificationType {
+    SUCCESS,
+    ERROR
+};
diff --git a/test/_helpers/createMockStore.ts b/test/_helpers/createMockStore.ts
deleted file mode 100644
index 231e3c4..0000000
--- a/test/_helpers/createMockStore.ts
+++ /dev/null
@@ -1,24 +0,0 @@
-import createSagaMiddleware from "redux-saga";
-// import { browserHistory } from "react-router";
-// import { routerMiddleware } from "react-router-redux";
-import sagas from "../../src/sagas";
-
-/* tslint:disable:no-var-requires */
-const configureStore = require("redux-mock-store");
-/* tslint:enable:no-var-requires */
-
-export default function createMockStore(state) {
-  const sagaMiddleware = createSagaMiddleware();
-
-  const middlewares = [
-    // routerMiddleware(browserHistory),
-    sagaMiddleware,
-  ];
-
-  const mockStore = configureStore(middlewares);
-  const store = mockStore(<any> state);
-
-  sagaMiddleware.run(sagas);
-
-  return store;
-}
diff --git a/test/actions/definition.spec.ts b/test/actions/definition.spec.ts
deleted file mode 100644
index aa9c08f..0000000
--- a/test/actions/definition.spec.ts
+++ /dev/null
@@ -1,45 +0,0 @@
-import * as expect from "expect";
-
-import {
-  DEFINITION_START,
-  DEFINITION_DONE,
-  DEFINITION_ERROR,
-  definitionStart,
-  definitionDone,
-  definitionError,
-} from "../../src/actions/definition";
-
-describe("Action", () => {
-  describe("Define", () => {
-    it("starts a definition lookup", () => {
-      const query = "test";
-      const action = {
-        payload: query,
-        type: DEFINITION_START,
-      };
-
-      expect(definitionStart(query)).toEqual(action);
-    });
-
-    it("completes a definition lookup", () => {
-      const results = ["test"];
-      const action = {
-        payload: results,
-        type: DEFINITION_DONE,
-      };
-
-      expect(definitionDone(results)).toEqual(action);
-    });
-
-    it("completes a definition lookup with error", () => {
-      const error = new Error("test");
-      const action = {
-        error: true,
-        payload: error,
-        type: DEFINITION_ERROR,
-      };
-
-      expect(definitionError(error)).toEqual(action);
-    });
-  });
-});
diff --git a/test/actions/search.spec.ts b/test/actions/search.spec.ts
deleted file mode 100644
index 0f22f99..0000000
--- a/test/actions/search.spec.ts
+++ /dev/null
@@ -1,45 +0,0 @@
-import * as expect from "expect";
-
-import {
-  SEARCH_START,
-  SEARCH_DONE,
-  SEARCH_ERROR,
-  searchStart,
-  searchDone,
-  searchError,
-} from "../../src/actions/search";
-
-describe("Action", () => {
-  describe("Search", () => {
-    it("starts a search", () => {
-      const query = "test";
-      const action = {
-        payload: query,
-        type: SEARCH_START,
-      };
-
-      expect(searchStart(query)).toEqual(action);
-    });
-
-    it("completes a search", () => {
-      const results = ["test"];
-      const action = {
-        payload: results,
-        type: SEARCH_DONE,
-      };
-
-      expect(searchDone(results)).toEqual(action);
-    });
-
-    it("completes a search with error", () => {
-      const error = new Error("test");
-      const action = {
-        error: true,
-        payload: error,
-        type: SEARCH_ERROR,
-      };
-
-      expect(searchError(error)).toEqual(action);
-    });
-  });
-});
diff --git a/test/api/DictionaryAPI.spec.ts b/test/api/DictionaryAPI.spec.ts
deleted file mode 100644
index 81bfe8d..0000000
--- a/test/api/DictionaryAPI.spec.ts
+++ /dev/null
@@ -1,95 +0,0 @@
-import * as expect from "expect";
-import * as nock from "nock";
-import { search, define } from "../../src/api/DictionaryAPI";
-
-describe("Dictionary API", () => {
-  describe("search", () => {
-    let mockRequest;
-
-    beforeEach(() => {
-      mockRequest = nock(/.*/)
-        .get("/api/search-json");
-    });
-
-    it("returns a list of entries on success", async () => {
-      /* tslint:disable:no-var-requires */
-      const mockResult = require("./fixtures/search-a.json");
-      /* tslint:enable:no-var-requires */
-
-      mockRequest.query({prefix: "a"}).reply(200, mockResult);
-
-      const results = await search("a");
-      expect(results.length).toEqual(mockResult.list.length);
-    });
-
-    it("returns an error on failure", async () => {
-      mockRequest.query({prefix: "error"}).reply(500);
-
-      try {
-        await search("error");
-
-      } catch (error) {
-        expect(error).toExist();
-      }
-    });
-  });
-
-  describe("define", () => {
-    let mockRequest;
-
-    beforeEach(() => {
-      mockRequest = nock(/.*/);
-    });
-
-    it("returns a single entry on success", async () => {
-      /* tslint:disable:no-var-requires */
-      const mockResult = require("./fixtures/define-b.json");
-      /* tslint:enable:no-var-requires */
-      const word = "b";
-
-      mockRequest
-        .get("/api/search-json/" + word)
-        .reply(200, mockResult);
-
-      const results = await define("b");
-
-      results.forEach((result) => {
-        expect(result.word).toEqual(word);
-        expect(result.id).toEqual(mockResult.entry["@id"]);
-        expect(result.raw).toEqual(mockResult.entry);
-      });
-    });
-
-    it("returns multiple entries on success", async () => {
-      const word = "a";
-      /* tslint:disable:no-var-requires */
-      const mockResult = require("./fixtures/define-a.json");
-      /* tslint:enable:no-var-requires */
-
-      mockRequest
-        .get("/api/search-json/" + word)
-        .reply(200, mockResult);
-
-      const results = await define("a");
-
-      results.forEach((result, index) => {
-        expect(result.word).toEqual(word);
-        expect(result.id).toEqual(mockResult.superEntry[index].entry["@id"]);
-        expect(result.raw).toEqual(mockResult.superEntry[index].entry);
-      });
-    });
-
-    it("returns an Not Found error on failure", async () => {
-      mockRequest
-        .get("/api/search-json/error")
-        .reply(404);
-
-      try {
-        await define("error");
-
-      } catch (error) {
-        expect(error.message.match(/Not Found/)).toExist();
-      }
-    });
-  });
-});
diff --git a/test/api/Entry.spec.ts b/test/api/Entry.spec.ts
deleted file mode 100644
index 5d399f9..0000000
--- a/test/api/Entry.spec.ts
+++ /dev/null
@@ -1,105 +0,0 @@
-import * as expect from "expect";
-import { createEntry, createEntryStub } from "../../src/api/Entry";
-
-/* tslint:disable:no-var-requires */
-const defineAFixture = require("./fixtures/define-a.json");
-/* tslint:enable:no-var-requires */
-
-describe("Entry factory", () => {
-  context("creating an entry stub from word", () => {
-    const word = "word";
-    const entry = createEntryStub(word);
-
-    it("sets an ID equal to word", () => {
-      expect(entry.id).toBe(word);
-    });
-
-    it("sets the word", () => {
-      expect(entry.word).toBe(word);
-    });
-
-    it("sets no senses", () => {
-      expect(entry.senses).toEqual([]);
-    });
-  });
-
-  context("creating an entry from null data", () => {
-    it("is the same as creating an entry stub", () => {
-      const id = "a:1";
-      const word = "a";
-      const entry = createEntry(word, id, null);
-      const entryStub = createEntryStub(word, id);
-      expect(entry).toEqual(entryStub);
-    });
-  });
-
-  context("creating an entry from raw data", () => {
-    let raw;
-    let entry;
-    let id;
-    let word;
-
-    beforeEach(() => {
-      word = "a";
-      id = "a:1";
-      raw = defineAFixture.superEntry[0].entry;
-      entry = createEntry(word, id, raw);
-    });
-
-    it("sets the ID", () => {
-      expect(entry.id).toBe(id);
-    });
-
-    it("sets the word", () => {
-      expect(entry.word).toBe(word);
-    });
-
-    it("sets the raw content", () => {
-      expect(entry.raw).toEqual(raw);
-    });
-
-    it("sets the etymology", () => {
-      raw = defineAFixture.superEntry[1].entry;
-      entry = createEntry(word, id, raw);
-      expect(entry.etymology).toBe(raw.etym["#text"]);
-    });
-
-    it("sets the orthography", () => {
-      expect(entry.spelling).toBe(raw.form.orth);
-    });
-
-    it("sets the pronunciation", () => {
-      expect(entry.pronunciation).toBe(raw.form.pron);
-    });
-
-    it("sets the index", () => {
-      expect(entry.index).toBe(parseInt(raw["@n"], 10));
-    });
-
-    it("sets the ID", () => {
-      expect(entry.id).toBe(raw["@id"]);
-    });
-
-    it("sets senses", () => {
-      expect(entry.senses.length).toEqual(raw.sense.length);
-    });
-
-    it("sets sense definitions", () => {
-      entry.senses.forEach((sense, i) => {
-        expect(sense.definition).toEqual(raw.sense[i].def);
-      });
-    });
-
-    it("sets sense grammar groups", () => {
-      entry.senses.forEach((sense, i) => {
-        expect(sense.grammarGroup).toEqual(raw.sense[i].gramGrp);
-      });
-    });
-
-    it("sets sense usages", () => {
-      entry.senses.forEach((sense, i) => {
-        expect(sense.usage).toEqual(raw.sense[i].usg && raw.sense[i].usg["#text"]);
-      });
-    });
-  });
-});
diff --git a/test/api/fixtures/define-a.json b/test/api/fixtures/define-a.json
deleted file mode 100644
index ac72c0c..0000000
--- a/test/api/fixtures/define-a.json
+++ /dev/null
@@ -1,39 +0,0 @@
-{"superEntry" : [ {"entry" : {
- "@n" : "1",
- "@id" : "a:1",
- "@type" : "hom",
-"form" : {
-"orth" : "A","pron" : "√°"},"sense" : [{"gramGrp" : "m.",
-"def" : "Primeira letra do alfabeto portugu√™s."},
-{ "@ast" : "1",
-"usg" : {
- "@type" : "dom",
- "#text" : "M√∫s."
-},"def" : "Primeira nota da escala na denomina√ß√£o alfab√©tica dos sons."},
-{"gramGrp" : "Adj.",
-"def" : "Primeiro, (falando-se de um n√∫mero ou de um objecto que faz parte de uma s√©rie)."},
-{ "@ast" : "1",
-"gramGrp" : "Adj.",
-"def" : "Que √© de primeira classe, (falando-se de carruagens de caminho de ferro)."}]}},{"entry" : {
- "@n" : "2",
- "@type" : "hom",
- "@id" : "a:2",
-"form" : {
-"orth" : "A","pron" : "√°"},"sense" : [{"gramGrp" : "art.",
-"def" : "(fem. de o).<br/>Ant. _la_."}],"etym" : {
- "@orig" : "lat",
- "#text" : "(Do lat. _illa_)"
-}}},{"entry" : {
- "@n" : "3",
- "@type" : "hom",
- "@id" : "a:3",
-"form" : {
-"orth" : "A","pron" : "√¢"},"sense" : [{"gramGrp" : "prep.",
-"def" : "Que indica v√°rias rela√ß√µes.<br/>(Lat. _ad_)."}]}},{"entry" : {
- "@n" : "4",
- "@id" : "a:4",
- "@type" : "hom",
- "@ast" : "1",
-"form" : {
-"orth" : "A","pron" : "√¢"},"sense" : [{"gramGrp" : "pron.",
-"def" : "Flex√£o feminina do pronome _o_."}]}}]}
diff --git a/test/api/fixtures/define-b.json b/test/api/fixtures/define-b.json
deleted file mode 100644
index 855bc84..0000000
--- a/test/api/fixtures/define-b.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{"entry" : {
- "@id" : "b",
-"form" : {
-"orth" : "B","pron" : "b√™"},"sense" : [{"gramGrp" : "m.",
-"def" : "Letra, que representa som labial, e que ocupa o segundo lugar no alfabeto portugu√™s.<br/>Abrev. de _bom_: _no concurso de escriv√£o, obteve a nota de B_."},
-{ "@ast" : "1",
-"usg" : {
- "@type" : "dom",
- "#text" : "M√∫s."
-},"def" : "O segundo grau da escala, na antiga nota√ß√£o alfab√©tica."},
-{"gramGrp" : "Adj.",
-"def" : "Segundo, (falando-se de um n√∫mero ou de um objecto, que faz parte de uma s√©rie): _o livro B das Conservat√≥rias do registo predial_.<br/>Que √© de segunda classe, (falando-se de carruagens do caminho de ferro)."}]}}
diff --git a/test/api/fixtures/search-a.json b/test/api/fixtures/search-a.json
deleted file mode 100644
index 2739633..0000000
--- a/test/api/fixtures/search-a.json
+++ /dev/null
@@ -1,14 +0,0 @@
-{
-  "list": [
-    "a",
-    "a.",
-    "a...",
-    "a",
-    "a",
-    "a",
-    "a. c.",
-    "a final",
-    "a. m.",
-    "a-cantaros"
-  ]
-}
diff --git a/test/components/EntryDefinition.spec.tsx b/test/components/EntryDefinition.spec.tsx
deleted file mode 100644
index 3ca9789..0000000
--- a/test/components/EntryDefinition.spec.tsx
+++ /dev/null
@@ -1,81 +0,0 @@
-import * as expect from "expect";
-import * as React from "react";
-import "react-dom";
-import { shallow } from "enzyme";
-import { cloneDeep } from "lodash";
-import { createEntry } from "../../src/api/Entry";
-import EntryDefinition from "../../src/components/EntryDefinition";
-
-/* tslint:disable:no-var-requires */
-const defineAFixture = require("./fixtures/define-a.json");
-/* tslint:enable:no-var-requires */
-
-describe("<EntryDefinition />", () => {
-  let entry;
-  let data;
-
-  beforeEach(() => {
-    data = cloneDeep(defineAFixture.superEntry[0].entry);
-    entry = createEntry("a", "a:1", data);
-  });
-
-  it("renders", () => {
-    const wrapper = shallow(<EntryDefinition />);
-    expect(wrapper.is("article")).toBe(true);
-  });
-
-  it("renders with className", () => {
-    const className = "test";
-    const wrapper = shallow(<EntryDefinition {...{className}} />);
-    expect(wrapper.hasClass(className)).toBe(true);
-  });
-
-  it("renders title", () => {
-    const title = "test";
-    const wrapper = shallow(<EntryDefinition {...{title}} />);
-    expect(wrapper.find(".orth").first().text()).toBe(title);
-  });
-
-  it("renders entry index (n)", () => {
-    const wrapper = shallow(<EntryDefinition {...{entry}} />);
-    expect(wrapper.find(".n").first().text()).toBe(data["@n"]);
-  });
-
-  it("renders entry orthography", () => {
-    const wrapper = shallow(<EntryDefinition {...{entry}} />);
-    expect(wrapper.find(".orth").first().text()).toEqual(data.form.orth);
-  });
-
-  it("renders entry pronunciation", () => {
-    const wrapper = shallow(<EntryDefinition {...{entry}} />);
-    expect(wrapper.find(".pron").first().text()).toEqual(data.form.pron);
-  });
-
-  it("renders entry senses", () => {
-    const wrapper = shallow(<EntryDefinition {...{entry}} />);
-    expect(wrapper.find(".sense").length).toEqual(data.sense.length);
-  });
-
-  it("renders entry definitions", () => {
-    const wrapper = shallow(<EntryDefinition {...{entry}} />);
-    let i = 0;
-    wrapper.find(".def").forEach(def => expect(def.text()).toEqual(data.sense[i++].def));
-  });
-
-  context("when rendering definitions", () => {
-    it("converts line breaks", () => {
-      const parts = ["foo", "bar", "baz"];
-      data.sense[0].def = parts.join("<br />");
-      entry = createEntry("a", "a:1", data);
-      const wrapper = shallow(<EntryDefinition {...{entry}} />);
-      expect(wrapper.find("br").length).toEqual(parts.length - 1);
-    });
-
-    it("converts underscores to italics", () => {
-      data.sense[0].def = "foo _bar_ baz";
-      entry = createEntry("a", "a:1", data);
-      const wrapper = shallow(<EntryDefinition {...{entry}} />);
-      expect(wrapper.find("em").first().text()).toEqual("bar");
-    });
-  });
-});
diff --git a/test/components/EntryList.spec.tsx b/test/components/EntryList.spec.tsx
deleted file mode 100644
index 5c29778..0000000
--- a/test/components/EntryList.spec.tsx
+++ /dev/null
@@ -1,35 +0,0 @@
-import * as expect from "expect";
-import * as React from "react";
-import "react-dom";
-import { shallow } from "enzyme";
-import EntryList from "../../src/components/EntryList";
-import EntryListItem from "../../src/components/EntryListItem";
-import { createEntry } from "../../src/api/Entry";
-
-describe("Component", () => {
-  describe("<EntryList />", () => {
-    let entries;
-
-    before(() => {
-      entries = ["one", "two", "three"].map(
-        (value) => createEntry(value, value, { "@n": "1", "@id": "n:1", form: { orth: "n" }, sense: [] })
-      );
-    });
-
-    it("should render", () => {
-      const wrapper = shallow(<EntryList {...{entries}} />);
-      expect(wrapper.is("ul")).toBe(true);
-    });
-
-    it("should render <EntryList /> with className", () => {
-      const className: string = "test";
-      const wrapper = shallow(<EntryList {...{className, entries}} />);
-      expect(wrapper.hasClass(className)).toBe(true);
-    });
-
-    it("should contain all entries inside <EntryListItem /> components", () => {
-      const wrapper = shallow(<EntryList {...{entries}} />);
-      expect(wrapper.find(EntryListItem).length).toBe(entries.length);
-    });
-  });
-});
diff --git a/test/components/EntryListItem.spec.tsx b/test/components/EntryListItem.spec.tsx
deleted file mode 100644
index cab9fbd..0000000
--- a/test/components/EntryListItem.spec.tsx
+++ /dev/null
@@ -1,45 +0,0 @@
-import * as expect from "expect";
-import * as React from "react";
-import "react-dom";
-import { shallow, mount } from "enzyme";
-import { createEntryStub, IEntry } from "../../src/api/Entry";
-import EntryListItem from "../../src/components/EntryListItem";
-
-describe("Component", () => {
-  describe("<EntryListItem />", () => {
-    let word: string;
-    let id: string;
-    let entry: IEntry;
-
-    beforeEach(() => {
-      word = "word";
-      id = "id";
-      entry = createEntryStub(word, id);
-    });
-
-    it("renders", () => {
-      const wrapper = shallow(<EntryListItem {...{entry}}/>);
-      expect(wrapper.is("li")).toBe(true);
-    });
-
-    it("renders with className", () => {
-      const className = "test";
-      const wrapper = shallow(<EntryListItem {...{className, entry}} />);
-      expect(wrapper.hasClass(className)).toBe(true);
-    });
-
-    it("renders with name", () => {
-
-      const wrapper = mount(<EntryListItem {...{entry}} />);
-      expect(wrapper.find("Link").text()).toBe(word);
-    });
-
-    it("renders a Link", () => {
-      word = "word";
-      id = "id";
-      entry = createEntryStub(word, id);
-      const wrapper = shallow(<EntryListItem {...{entry}} />);
-      expect(wrapper.find("Link").prop("to")).toBe(`/define/${id}`);
-    });
-  });
-});
diff --git a/test/components/Footer.spec.tsx b/test/components/Footer.spec.tsx
deleted file mode 100644
index 3b4b839..0000000
--- a/test/components/Footer.spec.tsx
+++ /dev/null
@@ -1,19 +0,0 @@
-import * as expect from "expect";
-import * as React from "react";
-import "react-dom";
-import { shallow } from "enzyme";
-import Footer from "../../src/components/Footer";
-
-describe("Component", () => {
-  describe("<Footer />", () => {
-    let wrapper;
-
-    before(() => {
-      wrapper = shallow(<Footer />);
-    });
-
-    it("renders", () => {
-      expect(wrapper.is("footer")).toBe(true);
-    });
-  });
-});
diff --git a/test/components/Header.spec.tsx b/test/components/Header.spec.tsx
deleted file mode 100644
index cf05329..0000000
--- a/test/components/Header.spec.tsx
+++ /dev/null
@@ -1,20 +0,0 @@
-import * as expect from "expect";
-import * as React from "react";
-import "react-dom";
-import { shallow } from "enzyme";
-import Header from "../../src/components/Header";
-
-describe("Component", () => {
-  describe("<Header />", () => {
-    it("renders", () => {
-      const wrapper = shallow(<Header title="" />);
-      expect(wrapper.is("header")).toBe(true);
-    });
-
-    it("displays a title", () => {
-      const title = "test";
-      const wrapper = shallow(<Header {...{title}} />);
-      expect(wrapper.find("h1").text()).toBe(title);
-    });
-  });
-});
diff --git a/test/components/LoadingIndicator.spec.tsx b/test/components/LoadingIndicator.spec.tsx
deleted file mode 100644
index 917f1a0..0000000
--- a/test/components/LoadingIndicator.spec.tsx
+++ /dev/null
@@ -1,20 +0,0 @@
-import * as expect from "expect";
-import * as React from "react";
-import "react-dom";
-import { shallow } from "enzyme";
-import LoadingIndicator from "../../src/components/LoadingIndicator";
-
-describe("Component", () => {
-  describe("<LoadingIndicator />", () => {
-    it("renders", () => {
-      const wrapper = shallow(<LoadingIndicator />);
-      expect(wrapper.is("div")).toBe(true);
-    });
-
-    it("renders with className", () => {
-      const className = "test";
-      const wrapper = shallow(<LoadingIndicator {...{className}} />);
-      expect(wrapper.is("." + className)).toBe(true);
-    });
-  });
-});
diff --git a/test/components/SearchInput.spec.tsx b/test/components/SearchInput.spec.tsx
deleted file mode 100644
index e03f5c6..0000000
--- a/test/components/SearchInput.spec.tsx
+++ /dev/null
@@ -1,59 +0,0 @@
-import * as expect from "expect";
-import * as React from "react";
-import "react-dom";
-import { shallow } from "enzyme";
-import * as sinon from "sinon";
-import SearchInput from "../../src/components/SearchInput";
-import LoadingIndicator from "../../src/components/LoadingIndicator";
-
-describe("<SearchInput />", () => {
-  it("renders", () => {
-    const wrapper = shallow(<SearchInput />);
-    expect(wrapper.find("input").length).toBe(1);
-  });
-
-  it("renders with className", () => {
-    const className: string = "test";
-    const wrapper = shallow(<SearchInput {...{className}} />);
-    expect(wrapper.hasClass(className)).toBe(true);
-  });
-
-  it("invokes onChange callbacks", () => {
-    const onChange = sinon.spy();
-    const event = { target: { value: "test" } };
-    const wrapper = shallow(<SearchInput {...{onChange}} />);
-    wrapper.find("input").simulate("change", event);
-    expect(onChange.callCount).toBe(1);
-    expect(onChange.calledWith(event)).toBe(true);
-  });
-
-  context("when pressing the Enter key", () => {
-    it("invokes onSubmit callbacks with field value", () => {
-      const onSubmit = sinon.spy();
-      const text = "test";
-      const wrapper = shallow(<SearchInput {...{onSubmit, text}} />);
-      const event = { keyCode: 13 };
-      wrapper.find("input").simulate("keyup", event);
-      expect(onSubmit.callCount).toBe(1);
-      expect(onSubmit.calledWith(text)).toBe(true);
-    });
-  });
-
-  context("when loading", () => {
-    it("displays a loading indicator", () => {
-      const loadingIndicator = <div className="loading">...</div>;
-      const isLoading = true;
-      const wrapper = shallow(<SearchInput {...{loadingIndicator, isLoading}} />);
-      expect(wrapper.find(LoadingIndicator).length).toBe(1);
-    });
-  });
-
-  context("when not loading", () => {
-    it("does not display a loading indicator", () => {
-      const loadingIndicator = <div className="loading">...</div>;
-      const isLoading = false;
-      const wrapper = shallow(<SearchInput {...{loadingIndicator, isLoading}} />);
-      expect(wrapper.find(LoadingIndicator).length).toBe(0);
-    });
-  });
-});
diff --git a/test/components/Warning.spec.tsx b/test/components/Warning.spec.tsx
deleted file mode 100644
index e53a404..0000000
--- a/test/components/Warning.spec.tsx
+++ /dev/null
@@ -1,25 +0,0 @@
-import * as expect from "expect";
-import * as React from "react";
-import "react-dom";
-import { shallow } from "enzyme";
-import Warning from "../../src/components/Warning";
-
-describe("Component", () => {
-  describe("<Warning />", () => {
-    it("renders", () => {
-      const wrapper = shallow(<Warning />);
-      expect(wrapper.is("div.error")).toBe(true);
-    });
-
-    it("renders with message", () => {
-      const message = "Warning message";
-      const wrapper = shallow(<Warning {...{message}} />);
-      expect(wrapper.find("div.message").text()).toBe(message);
-    });
-
-    it("renders with default message", () => {
-      const wrapper = shallow(<Warning />);
-      expect(wrapper.find("div.message").text()).toBe("Erro");
-    });
-  });
-});
diff --git a/test/components/fixtures/define-a.json b/test/components/fixtures/define-a.json
deleted file mode 100644
index ac72c0c..0000000
--- a/test/components/fixtures/define-a.json
+++ /dev/null
@@ -1,39 +0,0 @@
-{"superEntry" : [ {"entry" : {
- "@n" : "1",
- "@id" : "a:1",
- "@type" : "hom",
-"form" : {
-"orth" : "A","pron" : "√°"},"sense" : [{"gramGrp" : "m.",
-"def" : "Primeira letra do alfabeto portugu√™s."},
-{ "@ast" : "1",
-"usg" : {
- "@type" : "dom",
- "#text" : "M√∫s."
-},"def" : "Primeira nota da escala na denomina√ß√£o alfab√©tica dos sons."},
-{"gramGrp" : "Adj.",
-"def" : "Primeiro, (falando-se de um n√∫mero ou de um objecto que faz parte de uma s√©rie)."},
-{ "@ast" : "1",
-"gramGrp" : "Adj.",
-"def" : "Que √© de primeira classe, (falando-se de carruagens de caminho de ferro)."}]}},{"entry" : {
- "@n" : "2",
- "@type" : "hom",
- "@id" : "a:2",
-"form" : {
-"orth" : "A","pron" : "√°"},"sense" : [{"gramGrp" : "art.",
-"def" : "(fem. de o).<br/>Ant. _la_."}],"etym" : {
- "@orig" : "lat",
- "#text" : "(Do lat. _illa_)"
-}}},{"entry" : {
- "@n" : "3",
- "@type" : "hom",
- "@id" : "a:3",
-"form" : {
-"orth" : "A","pron" : "√¢"},"sense" : [{"gramGrp" : "prep.",
-"def" : "Que indica v√°rias rela√ß√µes.<br/>(Lat. _ad_)."}]}},{"entry" : {
- "@n" : "4",
- "@id" : "a:4",
- "@type" : "hom",
- "@ast" : "1",
-"form" : {
-"orth" : "A","pron" : "√¢"},"sense" : [{"gramGrp" : "pron.",
-"def" : "Flex√£o feminina do pronome _o_."}]}}]}
diff --git a/test/containers/App.spec.tsx b/test/containers/App.spec.tsx
deleted file mode 100644
index ad6181c..0000000
--- a/test/containers/App.spec.tsx
+++ /dev/null
@@ -1,32 +0,0 @@
-import * as expect from "expect";
-import * as React from "react";
-import "react-dom";
-import { shallow } from "enzyme";
-import App from "../../src/containers/App";
-import Header from "../../src/components/Header";
-import Footer from "../../src/components/Footer";
-
-describe("<App />", () => {
-  let wrapper;
-
-  before(() => {
-    wrapper = shallow(<App />);
-  });
-
-  it("renders a <div />", () => {
-    expect(wrapper.find("div").first().hasClass("dictionary-app")).toBe(true);
-  });
-
-  it("contains a single <Header /> component", () => {
-    expect(wrapper.find(Header).length).toBe(1);
-  });
-
-  it("allows children components", () => {
-    wrapper = shallow(<App><section className="child" /></App>);
-    expect(wrapper.find("section.child").length).toBe(1);
-  });
-
-  it("contains a single <Footer /> component", () => {
-    expect(wrapper.find(Footer).length).toBe(1);
-  });
-});
diff --git a/test/containers/Definition.spec.tsx b/test/containers/Definition.spec.tsx
deleted file mode 100644
index 2b3780f..0000000
--- a/test/containers/Definition.spec.tsx
+++ /dev/null
@@ -1,151 +0,0 @@
-import * as expect from "expect";
-import * as React from "react";
-import "react-dom";
-import * as Helmet from "react-helmet";
-import { Provider } from "react-redux";
-import { mount } from "enzyme";
-import createMockStore from "../_helpers/createMockStore";
-import { definitionStart } from "../../src/actions/definition";
-import { createEntry } from "../../src/api/Entry";
-import { definitionTask } from "../../src/sagas/definition";
-import Definition from "../../src/containers/Definition";
-import EntryDefinition from "../../src/components/EntryDefinition";
-import LoadingIndicator from "../../src/components/LoadingIndicator";
-import Warning from "../../src/components/Warning";
-
-describe("<Definition />", () => {
-  let state;
-  let store;
-  let wrapper;
-
-  beforeEach(() => {
-    state = {
-      definition: {
-        entries: [],
-        error: null,
-        id: "",
-        isLoading: false,
-      },
-    };
-
-    store = createMockStore(state);
-
-    wrapper = mount(
-      <Provider store={store}>
-        <Definition />
-      </Provider>
-    );
-  });
-
-  it("preloads definitions", () => {
-    const id = "test";
-    const preloaders = (Definition as any).preload({ id });
-
-    preloaders.forEach(preloader => {
-      expect(preloader[0]).toBe(definitionTask);
-      expect(preloader[1]).toEqual(definitionStart(id));
-    });
-  });
-
-  it("renders", () => {
-    expect(wrapper.find(Definition).length).toBe(1);
-  });
-
-  it("contains an <EntryDefinition /> component per entry", () => {
-    state.definition.id = "teste:1";
-    state.definition.entries = [
-      createEntry("a", "a:1", { "@n": "1", "@id": "a:1", form: { orth: "A" }, sense: [] }),
-      createEntry("a", "a:2", { "@n": "2", "@id": "a:2", form: { orth: "A" }, sense: [] }),
-      createEntry("a", "a:3", { "@n": "3", "@id": "a:3", form: { orth: "A" }, sense: [] }),
-    ];
-    store = createMockStore(state);
-
-    wrapper = mount(
-      <Provider store={store}>
-        <Definition />
-      </Provider>
-    );
-
-    expect((Helmet as any).peek().title).toBe(state.definition.id.replace(/:\d+$/, ""));
-    expect(wrapper.find(EntryDefinition).length).toBe(state.definition.entries.length);
-    expect(wrapper.find(Warning).length).toBe(0);
-    expect(wrapper.find(LoadingIndicator).length).toBe(0);
-  });
-
-  it("does not dispatch actions on mount without an id parameter", () => {
-    const actions = store.getActions();
-    expect(actions.length).toBe(0);
-  });
-
-  it("dispatches a DEFINE_START on mount from id parameter", () => {
-    const id = "par√¢metro:1";
-    const params = { id };
-
-    wrapper = mount(
-      <Provider store={store}>
-        <Definition {...{params}} />
-      </Provider>
-    );
-
-    const actions = store.getActions();
-    expect(actions[0]).toEqual(definitionStart(id));
-  });
-
-  it("displays a loading indicator", () => {
-    state.definition.isLoading = true;
-
-    store = createMockStore(state);
-
-    wrapper = mount(
-      <Provider store={store}>
-        <Definition />
-      </Provider>
-    );
-
-    expect((Helmet as any).peek().title).toBe("A carregar...");
-    expect(wrapper.find(EntryDefinition).length).toBe(0);
-    expect(wrapper.find(Warning).length).toBe(0);
-    expect(wrapper.find(LoadingIndicator).length).toBe(1);
-  });
-
-  it("displays a warning on error", () => {
-    const message = "Error message";
-
-    state.definition.isLoading = false;
-    state.definition.error = new Error(message);
-
-    store = createMockStore(state);
-
-    wrapper = mount(
-      <Provider store={store}>
-        <Definition />
-      </Provider>
-    );
-
-    expect((Helmet as any).peek().title).toBe(message);
-    expect(wrapper.find(EntryDefinition).length).toBe(0);
-    expect(wrapper.find(Warning).length).toBe(1);
-    expect(wrapper.find(Warning).props().message).toBe(message);
-    expect(wrapper.find(LoadingIndicator).length).toBe(0);
-  });
-
-  it("displays a warning when no definition found", () => {
-    const message = "Palavra n√£o encontrada";
-
-    state.definition.entries = [];
-
-    store = createMockStore(state);
-
-    wrapper = mount(
-      <Provider store={store}>
-        <Definition />
-      </Provider>
-    );
-
-    expect((Helmet as any).peek().title).toBe(message);
-    expect(wrapper.find(EntryDefinition).length).toBe(0);
-    expect(wrapper.find(Warning).length).toBe(1);
-    expect(wrapper.find(Warning).props().message).toBe(message);
-    expect(wrapper.find(LoadingIndicator).length).toBe(0);
-  });
-});
diff --git a/test/containers/Document.spec.tsx b/test/containers/Document.spec.tsx
deleted file mode 100644
index 6bdc368..0000000
--- a/test/containers/Document.spec.tsx
+++ /dev/null
@@ -1,58 +0,0 @@
-import * as expect from "expect";
-import * as React from "react";
-import "react-dom";
-import { render, shallow } from "enzyme";
-import serialize = require("serialize-javascript");
-import createMockStore from "../_helpers/createMockStore";
-import Document from "../../src/containers/Document";
-
-describe("<Document />", () => {
-  let app;
-  let store;
-  let wrapper;
-
-  beforeEach(() => {
-    app = <div>App</div>;
-    store = createMockStore({ foo: "bar" });
-    wrapper = render(<Document app={app} store={store} />);
-  });
-
-  it("renders a <html /> tag", () => {
-    expect(wrapper.find("html").first()).toExist();
-  });
-
-  it("renders the app", () => {
-    expect(wrapper.find("#root").text()).toBe("App");
-  });
-
-  it("renders serialized state inside a footer <script> tag", () => {
-    expect(wrapper.find("body script").first().text())
-      .toBe(`window.__PRELOADED__=${serialize(store.getState())};`);
-  });
-
-  it("renders style link tags in the header", () => {
-    const assets = { main: { css: "main.css" }, vendor: { css: "vendor.css" } };
-    wrapper = shallow(<Document app={app} assets={assets} store={store} />);
-    const elements = wrapper.find("head link");
-
-    Object.keys(assets)
-      .filter(chunk => assets[chunk].css)
-      .forEach(chunk => {
-        const href = assets[chunk].css;
-        expect(elements.nodes.filter(node => node.props.href === href).length).toBe(1);
-      });
-  });
-
-  it("renders script tags in the footer", () => {
-    const assets = { main: { js: "main.js" }, vendor: { js: "vendor.js" } };
-    wrapper = shallow(<Document app={app} assets={assets} store={store} />);
-    const elements = wrapper.find("body script");
-
-    Object.keys(assets)
-      .filter(chunk => assets[chunk].js)
-      .forEach(chunk => {
-        const src = assets[chunk].js;
-        expect(elements.nodes.filter(node => node.props.src === src).length).toBe(1);
-      });
-  });
-});
diff --git a/test/containers/Search.spec.tsx b/test/containers/Search.spec.tsx
deleted file mode 100644
index 62ee94c..0000000
--- a/test/containers/Search.spec.tsx
+++ /dev/null
@@ -1,223 +0,0 @@
-import * as expect from "expect";
-import * as React from "react";
-import "react-dom";
-import * as Helmet from "react-helmet";
-import { Provider } from "react-redux";
-import { mount } from "enzyme";
-import createMockStore from "../_helpers/createMockStore";
-import { searchStart } from "../../src/actions/search";
-import { searchTask } from "../../src/sagas/search";
-import { createEntry } from "../../src/api/Entry";
-import Search from "../../src/containers/Search";
-import EntryList from "../../src/components/EntryList";
-import EntryListItem from "../../src/components/EntryListItem";
-import LoadingIndicator from "../../src/components/LoadingIndicator";
-import SearchInput from "../../src/components/SearchInput";
-import Warning from "../../src/components/Warning";
-
-describe("<Search />", () => {
-  let state;
-  let store;
-  let wrapper;
-
-  beforeEach(() => {
-    state = {
-      search: {
-        entries: [
-          createEntry("a", "a:1", { "@n": "1", "@id": "a:1", form: { orth: "A" }, sense: [] }),
-          createEntry("a", "a:2", { "@n": "2", "@id": "a:2", form: { orth: "A" }, sense: [] }),
-          createEntry("a", "a:3", { "@n": "3", "@id": "a:3", form: { orth: "A" }, sense: [] }),
-        ],
-        error: null,
-        isLoading: false,
-        params: {
-          prefix: "test",
-        },
-        prefix: "test",
-      },
-    };
-
-    store = createMockStore(state);
-
-    wrapper = mount(
-      <Provider store={store}>
-        <Search />
-      </Provider>
-    );
-  });
-
-  it("preloads search results", () => {
-    const prefix = "test";
-    const preloaders = (Search as any).preload({ prefix });
-
-    preloaders.forEach(preloader => {
-      expect(preloader[0]).toBe(searchTask);
-      expect(preloader[1]).toEqual(searchStart(prefix));
-    });
-  });
-
-  it("renders", () => {
-    expect(wrapper.find("section.search").length).toBe(1);
-  });
-
-  it("contains a single <SearchInput /> component", () => {
-    expect(wrapper.find(SearchInput).length).toBe(1);
-  });
-
-  it("contains a <EntryListItem /> per results entry", () => {
-    expect(wrapper.find(EntryListItem).length).toBe(state.search.entries.length);
-  });
-
-  ["test", "0", "", null].forEach((prefix) => {
-    const contextDescription = prefix != null ? `when searching "${prefix}"` : "when not searching";
-    const doesOrDoesNotDisplay = prefix ? "displays" : "does not display";
-
-    context(contextDescription, () => {
-      it(doesOrDoesNotDisplay + " an <EntryList /> component", () => {
-        state.search.prefix = prefix;
-
-        store = createMockStore(state);
-
-        wrapper = mount(
-          <Provider store={store}>
-            <Search />
-          </Provider>
-        );
-
-        expect(wrapper.find(EntryList).length).toBe(prefix ? 1 : 0);
-      });
-
-      it(doesOrDoesNotDisplay + " a loading indicator", () => {
-        state.search.isLoading = true;
-        state.search.prefix = prefix;
-
-        store = createMockStore(state);
-
-        wrapper = mount(
-          <Provider store={store}>
-            <Search />
-          </Provider>
-        );
-
-        expect(wrapper.find(LoadingIndicator).length).toBe(prefix ? 1 : 0);
-      });
-
-      it(doesOrDoesNotDisplay + " an error on no results", () => {
-        state.search.isLoading = false;
-        state.search.entries = [];
-        state.search.prefix = prefix;
-
-        store = createMockStore(state);
-
-        wrapper = mount(
-          <Provider store={store}>
-            <Search />
-          </Provider>
-        );
-
-        expect(wrapper.find(Warning).length).toBe(prefix ? 1 : 0);
-      });
-    });
-  });
-
-  it("displays a warning on error", () => {
-    const message = "Error message";
-
-    state.search.error = new Error(message);
-
-    store = createMockStore(state);
-
-    wrapper = mount(
-      <Provider store={store}>
-        <Search />
-      </Provider>
-    );
-
-    expect((Helmet as any).peek().title).toBe(message);
-    expect(wrapper.find(Warning).length).toBe(1);
-    expect(wrapper.find(Warning).props().message).toBe(message);
-  });
-
-  it("displays a warning when no definition found", () => {
-    const message = "Palavra n√£o encontrada";
-
-    state.search.entries = [];
-
-    store = createMockStore(state);
-
-    wrapper = mount(
-      <Provider store={store}>
-        <Search />
-      </Provider>
-    );
-
-    expect((Helmet as any).peek().title).toBe(message);
-    expect(wrapper.find(Warning).length).toBe(1);
-    expect(wrapper.find(Warning).props().message).toBe(message);
-  });
-
-  it("dispatches a SEARCH_START on query", () => {
-    const prefix = "test";
-
-    wrapper.find("input").simulate("change", {
-      target: {
-        value: prefix,
-      },
-    });
-
-    const actions = store.getActions();
-
-    expect(actions[1]).toEqual(searchStart(prefix));
-  });
-
-  it("sets the SearchInput text to the prefix parameter if property null", () => {
-    const prefix = "par√¢metro";
-    const params = { prefix };
-
-    state.search.prefix = null;
-
-    store = createMockStore(state);
-
-    wrapper = mount(
-      <Provider store={store}>
-        <Search {...{params}} />
-      </Provider>
-    );
-
-    expect(wrapper.find(SearchInput).props().text).toBe(prefix);
-  });
-
-  it("dispatches a SEARCH_START on mount with prefix parameter", () => {
-    const prefix = "par√¢metro";
-    const params = { prefix };
-
-    state.search.prefix = null;
-
-    store = createMockStore(state);
-
-    wrapper = mount(
-      <Provider store={store}>
-        <Search {...{params}} />
-      </Provider>
-    );
-
-    const actions = store.getActions();
-    expect(actions[0]).toEqual(searchStart(prefix));
-  });
-
-  xit("sets the URL for the current search when pressing the Enter key", () => {
-    const prefix = "test";
-
-    wrapper.find("input").simulate("change", {
-      target: {
-        value: prefix,
-      },
-    });
-
-    wrapper.find("input").simulate("keyup", {
-      keyCode: 13,
-    });
-
-    expect(window.location.pathname).toBe("/search/" + prefix);
-  });
-});
diff --git a/test/reducers/definition.spec.ts b/test/reducers/definition.spec.ts
deleted file mode 100644
index 88c3fa5..0000000
--- a/test/reducers/definition.spec.ts
+++ /dev/null
@@ -1,52 +0,0 @@
-import * as expect from "expect";
-import { definitionStart, definitionDone, definitionError } from "../../src/actions/definition";
-import { createEntry } from "../../src/api/Entry";
-import definitionReducer from "../../src/reducers/definition";
-
-describe("Definition reducer", () => {
-  const id = "test";
-  let initialState;
-
-  beforeEach(() => {
-    initialState = {
-      entries: [],
-      error: null,
-      isLoading: false,
-    };
-  });
-
-  it("provides an initial state", () => {
-    const action = { type: "" };
-    expect(definitionReducer(undefined, action)).toEqual(initialState);
-  });
-
-  it("handles DEFINITION_START actions", () => {
-    const action = definitionStart(id);
-    const actualState = definitionReducer(initialState, action);
-
-    expect(actualState).toNotEqual(initialState);
-    expect(actualState.isLoading).toBe(true);
-  });
-
-  it("handles DEFINITION_DONE actions", () => {
-    const entries = [ createEntry("a", "a:1", { "@n": "1", "@id": "a:1", form: { orth: "A" }, sense: [] }) ];
-    const action = definitionDone(entries);
-    const actualState = definitionReducer(initialState, action);
-
-    expect(actualState).toNotEqual(initialState);
-    expect(actualState.isLoading).toBe(false);
-    expect(actualState.entries).toEqual(entries);
-    expect(actualState.error).toBe(null);
-  });
-
-  it("handles DEFINITION_ERROR actions", () => {
-    const error = new Error("test");
-    const action = definitionError(error);
-    const actualState = definitionReducer(initialState, action);
-
-    expect(actualState).toNotEqual(initialState);
-    expect(actualState.isLoading).toBe(false);
-    expect(actualState.entries).toEqual([]);
-    expect(actualState.error).toBe(error);
-  });
-});
diff --git a/test/reducers/index.spec.ts b/test/reducers/index.spec.ts
deleted file mode 100644
index b5b9011..0000000
--- a/test/reducers/index.spec.ts
+++ /dev/null
@@ -1,8 +0,0 @@
-import * as expect from "expect";
-import reducers from "../../src/reducers";
-
-describe("Reducers", () => {
-  xit("are combined", () => {
-    expect(reducers).toExist();
-  });
-});
diff --git a/test/reducers/search.spec.ts b/test/reducers/search.spec.ts
deleted file mode 100644
index 1f8a031..0000000
--- a/test/reducers/search.spec.ts
+++ /dev/null
@@ -1,63 +0,0 @@
-import * as expect from "expect";
-import { searchStart, searchDone, searchError } from "../../src/actions/search";
-import { createEntry } from "../../src/api/Entry";
-import searchReducer from "../../src/reducers/search";
-
-describe("Search reducer", () => {
-  const error = new Error("test");
-  const prefix = "test";
-  let initialState;
-
-  beforeEach(() => {
-    initialState = {
-      entries: [],
-      error: null,
-      isLoading: false,
-      prefix: null,
-    };
-  });
-
-  it("provides an initial state", () => {
-    const action = { type: "" };
-    expect(searchReducer(undefined, action)).toEqual(initialState);
-  });
-
-  it("handles SEARCH_START actions", () => {
-    initialState.prefix = prefix;
-    const action = searchStart(prefix);
-    const actualState = searchReducer(initialState, action);
-
-    expect(actualState).toNotEqual(initialState);
-    expect(actualState.isLoading).toBe(true);
-    expect(actualState.prefix).toBe(prefix);
-  });
-
-  it("handles SEARCH_DONE actions", () => {
-    initialState.prefix = prefix;
-    const entries = [
-      createEntry("a", "a:1", { "@n": "1", "@id": "a:1", form: { orth: "A" }, sense: [] }),
-      createEntry("a", "a:2", { "@n": "2", "@id": "a:2", form: { orth: "A" }, sense: [] }),
-      createEntry("a", "a:3", { "@n": "3", "@id": "a:3", form: { orth: "A" }, sense: [] }),
-    ];
-    const action = searchDone(entries);
-    const actualState = searchReducer(initialState, action);
-
-    expect(actualState).toNotEqual(initialState);
-    expect(actualState.isLoading).toBe(false);
-    expect(actualState.entries).toEqual(entries);
-    expect(actualState.prefix).toBe(prefix);
-    expect(actualState.error).toBe(null);
-  });
-
-  it("handles SEARCH_ERROR actions", () => {
-    initialState.prefix = prefix;
-    const action = searchError(error);
-    const actualState = searchReducer(initialState, action);
-
-    expect(actualState).toNotEqual(initialState);
-    expect(actualState.isLoading).toBe(false);
-    expect(actualState.entries).toEqual([]);
-    expect(actualState.prefix).toBe(prefix);
-    expect(actualState.error).toBe(error);
-  });
-});
diff --git a/test/routes.spec.ts b/test/routes.spec.ts
deleted file mode 100644
index cf8fdac..0000000
--- a/test/routes.spec.ts
+++ /dev/null
@@ -1,47 +0,0 @@
-import * as expect from "expect";
-import { match } from "react-router";
-import routes from "../src/routes";
-
-describe("Router", () => {
-  describe("/", () => {
-    it("routes to the Search component", () => {
-      match(<any> { location: "/", routes }, (error, redirectLocation, renderProps: {components: any[]}) => {
-        expect(renderProps.components[1].WrappedComponent.name).toBe("Search");
-      });
-    });
-  });
-
-  describe("/search/:prefix", () => {
-    const prefix = "test";
-    const location = `/search/${prefix}`;
-
-    it("routes to the Search component", () => {
-      match(<any> { location, routes }, (error, redirectLocation, renderProps: {components: any[]}) => {
-        expect(renderProps.components[1].WrappedComponent.name).toBe("Search");
-      });
-    });
-
-    it("captures the prefix param", () => {
-      match(<any> { location, routes }, (error, redirectLocation, renderProps: {params}) => {
-        expect(renderProps.params.prefix).toBe(prefix);
-      });
-    });
-  });
-
-  describe("/define/:id", () => {
-    const id = "test:1";
-    const location = `/define/${id}`;
-
-    it("routes to the Definition component", () => {
-      match(<any> { location, routes }, (error, redirectLocation, renderProps: {components: any[]}) => {
-        expect(renderProps.components[1].WrappedComponent.name).toBe("Definition");
-      });
-    });
-
-    it("captures the id param", () => {
-      match(<any> { location, routes }, (error, redirectLocation, renderProps: {params}) => {
-        expect(renderProps.params.id).toBe(id);
-      });
-    });
-  });
-});
diff --git a/test/sagas/definition.spec.ts b/test/sagas/definition.spec.ts
deleted file mode 100644
index 4415565..0000000
--- a/test/sagas/definition.spec.ts
+++ /dev/null
@@ -1,59 +0,0 @@
-import * as expect from "expect";
-import { put, call, take, fork } from "redux-saga/effects";
-import { define } from "../../src/api/DictionaryAPI";
-import definitionSaga, { definitionTask } from "../../src/sagas/definition";
-
-import {
-  DEFINITION_START,
-  definitionStart,
-  definitionDone,
-  definitionError,
-} from "../../src/actions/definition";
-
-describe("Definition saga", () => {
-  const sagaIterator = definitionSaga();
-
-  it("is started by a DEFINITION_START action", () => {
-    const result = sagaIterator.next();
-    expect(result.value).toEqual(take(DEFINITION_START));
-    expect(result.done).toBe(false);
-  });
-
-  it("forks a fetch result function generator", () => {
-    const result = sagaIterator.next();
-    expect(result.value).toEqual(fork(definitionTask, undefined));
-    expect(result.done).toBe(false);
-  });
-
-  describe("worker", () => {
-    const conditions = ["success", "error"];
-
-    conditions.forEach((condition) => {
-      it(`executes with ${condition}`, () => {
-        const id = "a:1";
-        const fetchIterator = definitionTask(definitionStart(id));
-        let result;
-
-        result = fetchIterator.next();
-        expect(result.value).toEqual(call(define, id));
-        expect(result.done).toBe(false);
-
-        if (condition === "success") {
-          result = fetchIterator.next();
-          expect(result.value).toEqual(put(definitionDone()));
-          expect(result.done).toBe(false);
-        }
-
-        if (condition === "error") {
-          const error = new Error();
-          result = fetchIterator.throw(error);
-          expect(result.value).toEqual(put(definitionError(error)));
-          expect(result.done).toBe(false);
-        }
-
-        result = fetchIterator.next();
-        expect(result.done).toBe(true);
-      });
-    });
-  });
-});
diff --git a/test/sagas/index.spec.ts b/test/sagas/index.spec.ts
deleted file mode 100644
index 0042fd4..0000000
--- a/test/sagas/index.spec.ts
+++ /dev/null
@@ -1,10 +0,0 @@
-import * as expect from "expect";
-import sagas from "../../src/sagas";
-
-describe("Sagas", () => {
-  xit("include the search saga", () => {
-    const iterator = sagas();
-    expect(iterator).toExist();
-    // TODO: How to test saga composition?
-  });
-});
diff --git a/test/sagas/search.spec.ts b/test/sagas/search.spec.ts
deleted file mode 100644
index bb84444..0000000
--- a/test/sagas/search.spec.ts
+++ /dev/null
@@ -1,80 +0,0 @@
-import * as expect from "expect";
-import { put, call, take, fork } from "redux-saga/effects";
-import { delay } from "redux-saga";
-import { search } from "../../src/api/DictionaryAPI";
-import searchSaga, { searchTask } from "../../src/sagas/search";
-
-import {
-  SEARCH_START,
-  searchStart,
-  searchDone,
-  searchError,
-} from "../../src/actions/search";
-
-describe("Search saga", () => {
-  const sagaIterator = searchSaga();
-
-  it("is started by a SEARCH_START action", () => {
-    const result = sagaIterator.next();
-    expect(result.value).toEqual(take(SEARCH_START));
-    expect(result.done).toBe(false);
-  });
-
-  it("forks a fetch result function generator", () => {
-    const result = sagaIterator.next();
-    expect(result.value).toEqual(fork(searchTask, undefined));
-    expect(result.done).toBe(false);
-  });
-
-  describe("worker", () => {
-    const conditions = ["success", "error"];
-
-    conditions.forEach((condition) => {
-      it(`executes with ${condition}`, () => {
-        const prefix = "a";
-        const fetchIterator = searchTask(searchStart(prefix));
-        let result;
-
-        result = fetchIterator.next();
-        expect(result.value).toEqual(call(delay, 200));
-        expect(result.done).toBe(false);
-
-        result = fetchIterator.next();
-        expect(result.value).toEqual(call(search, prefix));
-        expect(result.done).toBe(false);
-
-        if (condition === "success") {
-          result = fetchIterator.next();
-          expect(result.value).toEqual(put(searchDone()));
-          expect(result.done).toBe(false);
-        }
-
-        if (condition === "error") {
-          const error = new Error();
-          result = fetchIterator.throw(error);
-          expect(result.value).toEqual(put(searchError(error)));
-          expect(result.done).toBe(false);
-        }
-
-        result = fetchIterator.next();
-        expect(result.done).toBe(true);
-      });
-    });
-
-    const prefixes = ["", " "];
-
-    prefixes.forEach((prefix) => {
-      it(`executes with a "${prefix}" prefix`, () => {
-        const fetchIterator = searchTask(searchStart(prefix));
-        let result;
-
-        result = fetchIterator.next();
-        expect(result.value).toEqual(put(searchDone([])));
-        expect(result.done).toBe(false);
-
-        result = fetchIterator.next();
-        expect(result.done).toBe(true);
-      });
-    });
-  });
-});
diff --git a/test/server/compileAssets.spec.ts b/test/server/compileAssets.spec.ts
deleted file mode 100644
index e69de29..0000000
diff --git a/test/server/handleRoute.spec.ts b/test/server/handleRoute.spec.ts
deleted file mode 100644
index e69de29..0000000
diff --git a/test/server/index.spec.ts b/test/server/index.spec.ts
deleted file mode 100644
index e69de29..0000000
diff --git a/test/server/render.spec.tsx b/test/server/render.spec.tsx
deleted file mode 100644
index e69de29..0000000
diff --git a/test/store.spec.ts b/test/store.spec.ts
deleted file mode 100644
index 82d3889..0000000
--- a/test/store.spec.ts
+++ /dev/null
@@ -1,34 +0,0 @@
-import * as expect from "expect";
-import configureStore from "../src/store";
-
-describe("Store", () => {
-  describe("configureStore", () => {
-    let store;
-
-    beforeEach(() => {
-      store = configureStore();
-    });
-
-    it("has an initial state", () => {
-      expect(store.getState()).toExist();
-    });
-
-    it("has a custom initial state", () => {
-      const state = {
-        definition: "definition",
-        routing: {
-          locationBeforeTransitions: [ null ],
-        },
-        search: "search",
-      };
-
-      store = configureStore(state);
-
-      expect(store.getState()).toEqual(state);
-    });
-
-    xit("applies middlewares", () => {
-      // TODO
-    });
-  });
-});
diff --git a/test/typings/expect.spec.ts b/test/typings/expect.spec.ts
deleted file mode 100644
index 5862fae..0000000
--- a/test/typings/expect.spec.ts
+++ /dev/null
@@ -1,115 +0,0 @@
-/* tslint:disable */
-import * as expect from "expect";
-
-class Test {}
-
-function test_numbers() {
-  expect(0).toBe(0);
-  expect(0).toBeFalsy();
-  expect(0).toBeFewerThan(1);
-  expect(0).toBeGreaterThan(-1);
-  expect(0).toBeGreaterThanOrEqualTo(-1);
-  expect(0).toBeLessThan(1);
-  expect(0).toBeLessThanOrEqualTo(0);
-  expect(0).toBeMoreThan(-1);
-  expect(1).toBeTruthy();
-  expect(0).toEqual(0);
-  expect(1).toExist();
-  expect(0).toNotBe(1);
-  expect(0).toNotEqual(1);
-  expect(0).toNotExist();
-}
-
-function test_strings() {
-  expect("").toBe("");
-  expect("").toBeFalsy();
-  expect("test").toBeTruthy();
-  expect("test").toContain("test");
-  expect("").toEqual("");
-  expect("test").toExclude("tset");
-  expect("test").toExist();
-  expect("test").toInclude("test");
-  expect("test").toMatch(/test/);
-  expect("").toNotBe("test");
-  expect("test").toNotContain("tset");
-  expect("").toNotEqual("test");
-  expect("").toNotExist();
-  expect("test").toNotMatch(/tset/);
-}
-
-function test_arrays() {
-  expect([0]).toBe([0]);
-  expect([0]).toBeFalsy();
-  expect([0]).toBeTruthy();
-  expect([0]).toEqual([0]);
-  expect([0]).toExist();
-  expect([0]).toNotBe([1]);
-  expect([0]).toNotEqual([1]);
-  expect([0]).toNotExist();
-  // TODO: expect([0]).toContain(0);
-  // TODO: expect([0]).toExclude(0);
-  // TODO: expect([0]).toInclude(0);
-  // TODO: expect([0]).toNotContain(0);
-  // TODO: expect([0]).toNotInclude(0);
-}
-
-function test_objects() {
-  const test = new Test();
-
-  expect(test).toBe(test);
-  expect(test).toBeA("object");
-  expect(test).toBeA(Test);
-  expect(test).toBeAn("object");
-  expect(test).toBeAn(Test);
-  expect(test).toEqual(test);
-  expect(test).toExist();
-  expect(test).toNotBe({});
-  expect(test).toNotBeA("object");
-  expect(test).toNotBeA(Test);
-  expect(test).toNotBeAn("object");
-  expect(test).toNotBeAn(Test);
-  expect(test).toNotEqual({});
-  expect(test).toNotExist();
-}
-
-function test_functions() {
-  const test = i => i;
-
-  expect(test).toBe(test);
-  expect(test).toEqual(test);
-  expect(test).toExist();
-  expect(test).toNotBe(test);
-  expect(test).toNotEqual(test);
-  expect(test).toNotExist();
-  expect(test).toNotThrow();
-  expect(test).toThrow();
-  expect(test).withArgs();
-  expect(test).withContext(this);
-}
-
-function test_spies() {
-  // Spy
-  const spy = expect.createSpy<(a: number) => number>()
-  expect.isSpy(spy);
-  const otherSpy = expect.spyOn({}, "test");
-  expect.restoreSpies();
-
-  spy.andCall(() => {});
-  spy.andCallThrough();
-  spy.andReturn(1);
-  spy.andThrow(new Error("test"));
-  spy.restore();
-
-  spy(1);
-  spy.calls[0].arguments;
-  spy.calls[0].context;
-
-  expect(spy).toBe(spy);
-  expect(spy).toEqual(spy);
-  expect(spy).toExist();
-  expect(spy).toHaveBeenCalled();
-  expect(spy).toHaveBeenCalledWith();
-  expect(spy).toNotEqual(spy);
-  expect(spy).toNotExist();
-  expect(spy).toNotHaveBeenCalled();
-}
diff --git a/test/typings/serialize-javascript.spec.ts b/test/typings/serialize-javascript.spec.ts
deleted file mode 100644
index c1b9c3b..0000000
--- a/test/typings/serialize-javascript.spec.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import serialize = require("serialize-javascript");
-
-serialize(undefined); // => 'undefined'
-serialize(null); // => 'null'
-serialize(NaN); // => 'null'
-serialize(Infinity); // => 'null'
-
-serialize(""); // => '""'
-serialize("foo"); // => '"foo"'
-
-serialize(-1); // => '-1'
-serialize(0); // => '0'
-serialize(1); // => '1'
-
-serialize([]); // => '[]'
-serialize(["1", "2", "3"]); // => '["1","2","3""]'
-serialize([1, 2, 3]); // => '[1,2,3]'
-
-serialize({}); // => '{}'
-serialize({foo: "0"}); // => '{"foo":"0"}'
-serialize({foo: 0}); // => '{"foo":0}'
diff --git a/tools/json2ts.ts b/tools/json2ts.ts
new file mode 100644
index 0000000..5e4f5c3
--- /dev/null
+++ b/tools/json2ts.ts
@@ -0,0 +1,204 @@
+///<reference path="../typings/modules/lodash/index.d.ts" />
+
+import * as _ from 'lodash';
+
+interface IOptions {
+    wrappers: {
+        type: string;
+        int: string;
+    },
+    interfaces: string[];
+}
+
+export class Json2Ts {
+
+    convert(content: string, rootName: string, interfaceWrapper: string = "", typeWrapper: string = ""): string {
+        let jsonContent = JSON.parse(content);
+
+        let options: IOptions = {
+            wrappers: {
+                type: typeWrapper,
+                int: interfaceWrapper
+            },
+            interfaces: []
+        };
+
+        if (_.isArray(jsonContent)) {
+            return this.convertObjectToTsInterfaces(jsonContent[0], rootName, options);
+        }
+        return this.convertObjectToTsInterfaces(jsonContent, rootName, options) + "\n";
+    }
+
+    private makeUniqueInterface(key: string, path: string[], interfaces: string[]) {
+        let int = this.toUpperFirstLetter(key);
+
+        if (_.includes(interfaces, int)) {
+            let tail = -1;
+            while ((int = this.makeKey(path, tail, key)) && _.includes(interfaces, int)) {
+                tail = tail - 1;
+            }
+        }
+        interfaces.push(int);
+
+        return int;
+    }
+
+    private convertObjectToTsInterfaces(jsonContent: any, int, options: IOptions, path: string[] = []): string {
+        let optionalKeys: string[] = [];
+        let objectResult: string[] = [];
+
+        for (let key in jsonContent) {
+            let value = jsonContent[key];
+
+            if (_.isObject(value) && !_.isArray(value)) {
+                let childInterface = this.makeUniqueInterface(key, path, options.interfaces);
+                objectResult.push(this.convertObjectToTsInterfaces(value, childInterface, options, path.concat([childInterface])));
+                jsonContent[key] = this.removeMajority(childInterface, options) + ";";
+
+
+            } else if (_.isArray(value)) {
+                let arrayTypes: any = this.detectMultiArrayTypes(value);
+
+                if (this.isMultiArray(arrayTypes)) {
+                    let multiArrayBrackets = this.getMultiArrayBrackets(value);
+                    if (this.isAllEqual(arrayTypes)) {
+                        jsonContent[key] = this.wrapType(arrayTypes[0].replace("[]", multiArrayBrackets), options) + ";";
+                    } else {
+                        jsonContent[key] = this.wrapType("any" + multiArrayBrackets, options) + ";";
+                    }
+
+                } else if (value.length > 0 && _.isObject(value[0])) {
+                    let childInterface = this.makeUniqueInterface(key, path, options.interfaces);
+                    objectResult.push(this.convertObjectToTsInterfaces(value[0], childInterface, options, path.concat([childInterface])));
+                    jsonContent[key] = this.removeMajority(childInterface + "Item", options) + "[];";
+
+                } else {
+                    jsonContent[key] = this.wrapType(arrayTypes[0], options);
+                }
+
+            }
+            else if (_.isDate(value)) {
+                jsonContent[key] = this.wrapType("Date", options) + ";";
+            } else if (_.isString(value)) {
+                jsonContent[key] = this.wrapType("string", options) + ";";
+            } else if (_.isBoolean(value)) {
+                jsonContent[key] = this.wrapType("boolean", options) + ";";
+            } else if (_.isNumber(value)) {
+                jsonContent[key] = this.wrapType("number", options) + ";";
+            } else {
+                jsonContent[key] = this.wrapType("any", options) + ";";
+                optionalKeys.push(key);
+            }
+        }
+
+        let result = this.formatCharsToTypeScript(jsonContent, int, optionalKeys, options);
+        objectResult.push(result);
+
+        return objectResult.join("\n\n");
+    }
+
+    private wrapType(type: string, options: IOptions) {
+        if (options.wrappers.type) {
+            return options.wrappers.type.replace(/\$/g, type);
+        }
+        return type;
+    }
+
+    private detectMultiArrayTypes(value: any, valueType: string[] = []): string[] {
+        if (_.isArray(value)) {
+            if (value.length === 0) {
+                valueType.push("any[]");
+            } else if (_.isArray(value[0])) {
+                for (let index = 0, length = value.length; index < length; index++) {
+                    let element = value[index];
+
+                    let valueTypeResult = this.detectMultiArrayTypes(element, valueType);
+                    valueType.concat(valueTypeResult);
+                }
+            } else if (_.every(value, _.isString)) {
+                valueType.push("string[]");
+            } else if (_.every(value, _.isNumber)) {
+                valueType.push("number[]");
+            } else if (_.every(value, _.isBoolean)) {
+                valueType.push("boolean[]");
+            } else {
+                valueType.push("any[]");
+            }
+        }
+
+        return valueType;
+    }
+
+    private isMultiArray(arrayTypes: string[]) {
+        return arrayTypes.length > 1;
+    }
+
+    private isAllEqual(array: string[]) {
+        return _.every(array.slice(1), _.partial(_.isEqual, array[0]));
+    }
+
+    private getMultiArrayBrackets(content: string): string {
+        let jsonString = JSON.stringify(content);
+        let brackets = "";
+
+        for (let index = 0, length = jsonString.length; index < length; index++) {
+            let element = jsonString[index];
+
+            if (element === "[") {
+                brackets = brackets + "[]";
+            } else {
+                index = length;
+            }
+        }
+
+        return brackets;
+    }
+
+    private formatCharsToTypeScript(jsonContent: any, objectName: string, optionalKeys: string[], options: IOptions): string {
+        let result = JSON.stringify(jsonContent, null, "\t")
+            .replace(new RegExp("\"", "g"), "")
+            .replace(new RegExp(",", "g"), "");
+
+        let allKeys = _.keysIn(jsonContent);
+        for (let index = 0, length = allKeys.length; index < length; index++) {
+            let key = allKeys[index];
+            if (_.includes(optionalKeys, key)) {
+                result = result.replace(new RegExp(key + ":", "g"), this.toLowerFirstLetter(key) + "?:");
+            } else {
+                result = result.replace(new RegExp(key + ":", "g"), this.toLowerFirstLetter(key) + ":");
+            }
+        }
+
+        objectName = this.removeMajority(objectName, options);
+
+        return "export interface " + objectName + " " + result;
+    }
+
+    private removeMajority(objectName: string, options: IOptions): string {
+        let name = objectName;
+        if (objectName.slice(-3).toUpperCase() === "IES") {
+            name = objectName.substring(0, objectName.length - 3) + "y";
+        } else if (objectName.slice(-1).toUpperCase() === "S") {
+            name = objectName.substring(0, objectName.length - 1);
+        }
+
+        if (options.wrappers.int) {
+            return options.wrappers.int.replace(/\$/g, name);
+        }
+
+        return name;
+    }
+
+    private toUpperFirstLetter(text: string) {
+        return text.charAt(0).toUpperCase() + text.slice(1);
+    };
+
+    private toLowerFirstLetter(text: string) {
+        return text.charAt(0).toLowerCase() + text.slice(1);
+    };
+
+    private makeKey(path, tail, key) {
+        return path.slice(tail).concat([this.toUpperFirstLetter(key)]).join('');
+    }
+}
+
diff --git a/typings.json b/typings.json
index acd4475..8a764ce 100644
--- a/typings.json
+++ b/typings.json
@@ -3,6 +3,7 @@
     "es6-promise": "registry:npm/es6-promise#3.0.0+20160723033700",
     "lodash": "registry:npm/lodash#4.0.0+20160723033700",
     "mime": "registry:npm/mime#1.3.0+20160723033700",
+    "react-redux": "registry:npm/react-redux#4.4.0+20160614222153",
     "react-router": "registry:npm/react-router#2.4.0+20160803174347",
     "react-router-redux": "registry:npm/react-router-redux#4.0.0+20160602212457"
   },
@@ -16,12 +17,14 @@
     "classnames": "registry:dt/classnames#0.0.0+20160316155526",
     "express": "registry:dt/express#4.0.0+20160708185218",
     "express-serve-static-core": "registry:dt/express-serve-static-core#4.0.0+20160819131900",
+    "inversify": "registry:dt/inversify#2.0.0-rc.12+20160830145920",
     "isomorphic-fetch": "registry:dt/isomorphic-fetch#0.0.0+20160524142046",
     "node": "registry:env/node#6.0.0+20160813135048",
     "react": "registry:dt/react#0.14.0+20160817201227",
+    "react-addons-css-transition-group": "registry:dt/react-addons-css-transition-group#0.14.0+20160316155526",
+    "react-addons-transition-group": "registry:dt/react-addons-transition-group#0.14.0+20160701001352",
     "react-dom": "registry:dt/react-dom#0.14.0+20160412154040",
     "react-helmet": "registry:dt/react-helmet#0.0.0+20160816111147",
-    "react-redux": "registry:dt/react-redux#4.4.0+20160724070751",
     "redux": "registry:dt/redux#3.5.2+20160703092728",
     "redux-actions": "registry:dt/redux-actions#0.8.0+20160521154116",
     "serve-static": "registry:dt/serve-static#0.0.0+20160606155157"
diff --git a/typings/custom/expect.d.ts b/typings/custom/expect.d.ts
deleted file mode 100644
index 1293d21..0000000
--- a/typings/custom/expect.d.ts
+++ /dev/null
@@ -1,307 +0,0 @@
-declare module expect {
-
-  export interface IExpectation<TExpected> {
-    /**
-     * Asserts the given object is truthy.
-     */
-    toExist(message?: string): this;
-    toBeTruthy(message?: string): this;
-
-    /**
-     * Asserts the given object is falsy.
-     */
-    toNotExist(message?: string): this;
-    toBeFalsy(message?: string): this;
-
-    /**
-     * Asserts that object is strictly equal to value using ===.
-     */
-    toBe(value: TExpected, message?: string): this;
-
-    /**
-     * Asserts that object is strictly not equal to value using !==.
-     */
-    toNotBe(value: TExpected, message?: string): this;
-
-    /**
-     * Asserts that the given object equals value using is-equal.
-     */
-    toEqual(value: TExpected, message?: string): this;
-
-    /**
-     * Asserts that the given object is not equal to value using is-equal.
-     */
-    toNotEqual(value: TExpected, message?: string): this;
-  }
-
-  export interface IStringExpectation extends IExpectation<string> {
-    /**
-     * Asserts the given string matches pattern, which must be a RegExp.
-     */
-    toMatch(pattern: RegExp, message?: string): this;
-
-    /**
-     * Asserts the given string does not match pattern, which must be a RegExp.
-     */
-    toNotMatch(pattern: RegExp, message?: string): this;
-
-    /**
-     * Asserts the given string contains value.
-     */
-    toInclude(value: string, message?: string): this;
-
-    /**
-     * Asserts the given string contains value.
-     */
-    toContain(value: string, message?: string): this;
-
-    /**
-     * Asserts the given string does not contain value.
-     */
-    toExclude(value: string, message?: string): this;
-
-    /**
-     * Asserts the given string does not contain value.
-     */
-    toNotContain(value: string, message?: string): this;
-  }
-
-  export interface INumberExpectation extends IExpectation<number> {
-    /**
-     * Asserts the given number is less than value.
-     */
-    toBeLessThan(value: number, message?: string): this;
-    toBeFewerThan(value: number, message?: string): this;
-
-    /**
-     * Asserts the given number is less than or equal to value.
-     */
-    toBeLessThanOrEqualTo(value: number, message?: string): this;
-
-    /**
-     * Asserts the given number is greater than value.
-     */
-    toBeGreaterThan(value: number, message?: string): this;
-    toBeMoreThan(value: number, message?: string): this;
-
-    /**
-     * Asserts the given number is greater than or equal to value.
-     */
-    toBeGreaterThanOrEqualTo(value: number, message?: string): this;
-  }
-
-  export interface IObjectExpectation<TExpected extends Object> extends IExpectation<TExpected> {
-    /**
-     * Asserts the given object is an instanceof constructor.
-     * or
-     * Asserts the typeof the given object is string.
-     */
-    toBeA(constructor: Function | string, message?: string): this;
-    toBeAn(constructor: Function | string, message?: string): this;
-
-    /**
-     * Asserts the given object is not an instanceof constructor.
-     * or
-     * Asserts the typeof the given object not the string.
-     */
-    toNotBeA(constructor: Function | string, message?: string): this;
-    toNotBeAn(constructor: Function | string, message?: string): this;
-
-    /**
-     * Asserts the given object includes the provided key.
-     */
-    toIncludeKey(key: string, comparator?: IComparator<TExpected>, message?: string): this;
-
-    /**
-     * Asserts the given object includes all of the provided keys.
-     */
-    toIncludeKeys(keys: string[], comparator?: IComparator<TExpected>, message?: string): this;
-
-    /**
-     * Asserts the given object does not include the provided key.
-     */
-    toExcludeKey(key: string, comparator?: IComparator<TExpected>, message?: string): this;
-
-    /**
-     * Asserts the given object does not include any of the provided keys.
-     */
-    toExcludeKeys(keys: string[], comparator?: IComparator<TExpected>, message?: string): this;
-  }
-
-  export interface IArrayExpectation<TElement> extends IExpectation<TElement[]> {
-    /**
-     * Asserts the given array contains value. The comparator function, if given, should compare two objects and either return false or throw if they are not equal. It defaults to assert.deepEqual.
-     */
-    toInclude(value: TElement, comparator?: IComparator<TElement>, message?: string): this;
-    toContain(value: TElement, comparator?: IComparator<TElement>, message?: string): this;
-
-    /**
-     * Asserts the given array contains value. The comparator function, if given, should compare two objects and either return false or throw if they are not equal. It defaults to assert.deepEqual.
-     */
-    toExclude(value: TElement, comparator?: IComparator<TElement>, message?: string): this;
-    toNotContain(value: TElement, comparator?: IComparator<TElement>, message?: string): this;
-    toNotInclude(value: TElement, comparator?: IComparator<TElement>, message?: string): this;
-  }
-
-  export interface IFunctionExpectation<TExpected extends Function> extends IExpectation<TExpected> {
-    /**
-     * Asserts that the given block throws an error. The error argument may be a constructor (to test using instanceof), or a string/RegExp to test against error.message.
-     */
-    toThrow(error?: string | RegExp | Function, message?: string): this;
-
-    /**
-     * Asserts that the given block throws an error when called with args. The error argument may be a constructor (to test using instanceof), or a string/RegExp to test against error.message.
-     */
-    withArgs(...args: any[]): this;
-
-    /**
-     * Asserts that the given block throws an error when called in the given context. The error argument may be a constructor (to test using instanceof), or a string/RegExp to test against error.message.
-     */
-    withContext(context: any): this;
-
-    /**
-     * Asserts that the given block does not throw.
-     */
-    toNotThrow(message?: string): this;
-
-    /**
-     * Asserts the given function object includes the provided key.
-     */
-    toIncludeKey(key: string, comparator?: IComparator<TExpected>, message?: string): this;
-
-    /**
-     * Asserts the given function object includes all of the provided keys.
-     */
-    toIncludeKeys(keys: string[], comparator?: IComparator<TExpected>, message?: string): this;
-
-    /**
-     * Asserts the given function object does not include the provided key.
-     */
-    toExcludeKey(key: string, comparator?: IComparator<TExpected>, message?: string): this;
-
-    /**
-     * Asserts the given function object does not include any of the provided keys.
-     */
-    toExcludeKeys(keys: string[], comparator?: IComparator<TExpected>, message?: string): this;
-  }
-
-  export interface IComparator<TElement> {
-    (comparer: TElement, comparee: TElement): boolean;
-  }
-
-  export interface ISpyExpectation extends IExpectation<ISpy> {
-    /**
-     * Has the spy been called?
-     */
-    toHaveBeenCalled(message?: string): this;
-
-    toNotHaveBeenCalled(message?: string): this;
-
-    /**
-     * Has the spy been called with these arguments.
-     */
-    toHaveBeenCalledWith(...args: any[]): this;
-  }
-
-  export interface ISpy {
-    calls: ICall[];
-
-    /**
-     * Restores a spy originally created with expect.spyOn()
-     */
-    restore: () => void;
-
-    /**
-     * Makes the spy invoke a function fn when called.
-     */
-    andCall(fn: Function): this;
-
-    /**
-     * Makes the spy call the original function it's spying on.
-     */
-    andCallThrough(): this;
-
-    /**
-     * Makes the spy return a value;
-     */
-    andReturn(object: any): this;
-
-    /**
-     * Makes the spy throw an error when called.
-     */
-    andThrow(error: Error): this;
-  }
-
-  export interface ICall {
-    context: any;
-    arguments: any[];
-  }
-
-  /**
-   * This is my best attempt at emulating the typing required for expect extend.
-   * Unfortunately you'll still have to extend with IExpect interface or one of the
-   * Expectation interfaces to
-   */
-  export interface IExtension {
-    [assertionMethod: string]: Function;
-  }
-
-  export interface IExpect {
-    (compare: number): INumberExpectation;
-    (compare: string): IStringExpectation;
-    (spy: ISpy): ISpyExpectation;
-    <TExpected>(array: TExpected[]): IArrayExpectation<TExpected>;
-    <TExpected extends Function>(block: TExpected): IFunctionExpectation<TExpected>;
-    <TExpected extends Object>(object: TExpected): IObjectExpectation<TExpected>;
-    <TExpected>(compare: TExpected): IExpectation<TExpected>;
-
-    /**
-     * Creates a spy function.
-     */
-    //Probably could do more by typings the ISpy object with the generic type TFunc
-    createSpy<TFunc>(): ISpy & TFunc;
-
-    /**
-     * Replaces the method in target with a spy.
-     */
-    spyOn(target: any, method: string): ISpy;
-
-    /**
-     * Restores all spies created with expect.spyOn(). This is the same as calling spy.restore() on all spies created.
-     */
-    restoreSpies();
-
-    /**
-     * Determins if the object is a spy.
-     */
-    isSpy(object: any): boolean;
-
-    /**
-     * Does an assertion
-     */
-    assert(passed: boolean, message: string, actual: any);
-
-    /**
-     * You can add your own assertions using expect.extend and expect.assert
-     * A note here is that you'll have to extend the IExpect interface or one of the IExpectation interfaces have a look at
-     * typings-expect-element lib for an example
-     * @example
-     * expect.extend({
-     *   toBeAColor() {
-     *    expect.assert(
-     *     this.actual.match(/^#[a-fA-F0-9]{6}$/),
-     *     'expected %s to be an HTML color',
-     *     this.actual
-     *   )
-     *  }
-     * })
-     * expect('#ff00ff').toBeAColor()
-     */
-    extend(extension: IExtension | Object);
-  }
-}
-
-declare module "expect" {
-  let expect: expect.IExpect;
-  export = expect;
-}
diff --git a/typings/custom/serialize-javascript.d.ts b/typings/custom/serialize-javascript.d.ts
index cd68361..2b248f1 100644
--- a/typings/custom/serialize-javascript.d.ts
+++ b/typings/custom/serialize-javascript.d.ts
@@ -1,4 +1,4 @@
-declare module "serialize-javascript" {
-  function serialize(obj: Object, options?: Object): string;
-  export = serialize;
-}
+declare module 'serialize-javascript' {
+    function serialize(obj: Object, options?: Object): string;
+    export = serialize;
+}
\ No newline at end of file
diff --git a/webpack.config.js b/webpack.config.js
index 5e338dd..c6f63b7 100644
--- a/webpack.config.js
+++ b/webpack.config.js
@@ -1,74 +1,78 @@
-'use strict'
+const path = require('path');
+const webpack = require('webpack');
+const autoprefixer = require('autoprefixer');
+const CopyWebpackPlugin = require('copy-webpack-plugin');
+const ExtractTextPlugin = require('extract-text-webpack-plugin');

-const path = require('path')
-const webpack = require('webpack')
-const autoprefixer = require('autoprefixer')
-const CopyWebpackPlugin = require('copy-webpack-plugin')
-const ExtractTextPlugin = require('extract-text-webpack-plugin')
+const extractCSS = new ExtractTextPlugin('static/[name].css');

 module.exports = {
-  debug: true,
-  devtool: 'eval',
-  entry: {
-    main: [
-      'babel-polyfill',
-      'webpack-hot-middleware/client?reload=true&overlay=true',
-      './src/index'
-    ]
-  },
-  output: {
-    chunkFilename: '[name].[chunkhash].chunk.js',
-    filename: 'main.js',
-    path: path.join(__dirname, 'dist/static'),
-    publicPath: '/static/'
-  },
-  resolve: {
-    extensions: ['', '.ts', '.tsx', '.js', '.jsx']
-  },
-  plugins: [
-    new webpack.DefinePlugin({
-      'process.env': {
-        NODE_ENV: JSON.stringify(process.env.NODE_ENV),
-        PORT: JSON.stringify(process.env.PORT)
-      }
-    }),
-    new webpack.HotModuleReplacementPlugin(),
-    new webpack.NoErrorsPlugin(),
-    new CopyWebpackPlugin([
-      { context: 'assets', from: '**/*', to: '.' }
-    ]),
-    new ExtractTextPlugin('main.css')
-  ],
-  module: {
-    loaders: [
-      {
-        test: /\.tsx?$/,
-        loader: 'react-hot!babel?cacheDirectory!ts?sourceMap',
-        exclude: /node_modules/,
-        include: path.join(__dirname, 'src')
-      },
-      {
-        test: /\.css$/,
-        loader: 'style?sourceMap!css?importLoaders=1&modules&sourceMap&localIdentName=[name]__[local]___[hash:base64:5]',
-        include: path.join(__dirname, 'src')
-      },
-      {
-        test: /\.scss$/,
-        loader: 'style?sourceMap!css?importLoaders=1&modules&sourceMap&localIdentName=[name]__[local]___[hash:base64:5]!sass',
-        include: path.join(__dirname, 'src')
-      },
-      {
-        test: /\.(jpg|png|gif|eot|svg|ttf|woff|woff2)$/,
-        loader: 'file'
-      }
-    ]
-  },
-  postcss: () => [
-    autoprefixer
-  ],
-  sassLoader: {
-    outputStyle: 'expanded',
-    sourceMap: true,
-    sourceMapContents: true
-  }
-}
+    debug: true,
+    devtool: 'eval',
+    entry: {
+        main: [
+            'babel-polyfill',
+            'webpack-hot-middleware/client?reload=true&overlay=true',
+            './src/index'
+        ]
+    },
+    output: {
+        chunkFilename: '[name].[chunkhash].chunk.js',
+        filename: 'main.js',
+        path: path.join(__dirname, 'dist/static'),
+        publicPath: '/static/'
+    },
+    resolve: {
+        extensions: ['', '.ts', '.tsx', '.js', '.jsx']
+    },
+    plugins: [
+        new webpack.DefinePlugin({
+            'process.env': {
+                NODE_ENV: JSON.stringify(process.env.NODE_ENV),
+                PORT: JSON.stringify(process.env.PORT)
+            }
+        }),
+        new webpack.HotModuleReplacementPlugin(),
+        new webpack.NoErrorsPlugin(),
+        new CopyWebpackPlugin([
+            {context: 'assets', from: '**/*', to: '.'}
+        ]),
+        new ExtractTextPlugin('./static/main.css'),
+        new ExtractTextPlugin('main.css')
+    ],
+    module: {
+        loaders: [
+            {
+                test: /\.tsx?$/,
+                loader: 'react-hot!babel?cacheDirectory!ts?sourceMap',
+                exclude: /node_modules/,
+                include: path.join(__dirname, 'src')
+            },
+            {
+                test: /\.css$/,
+                loader: 'style?sourceMap!css?importLoaders=1&modules&sourceMap&localIdentName=[name]__[local]___[hash:base64:5]',
+                include: path.join(__dirname, 'src')
+            },
+
+            {
+                test: /\.scss$/,
+                loader: ExtractTextPlugin.extract(
+                    'style-loader',
+                    [
+                        'css-loader?modules&importLoaders=2&localIdentName=[name]__[local]___[hash:base64:5]',
+                        // 'postcss-loader',
+                        'sass'
+                    ]
+                )
+            },
+
+            {
+                test: /\.(jpg|png|gif|eot|svg|ttf|woff|woff2)$/,
+                loader: 'file'
+            }
+        ]
+    },
+    postcss: function () {
+        return [autoprefixer];
+    }
+};
